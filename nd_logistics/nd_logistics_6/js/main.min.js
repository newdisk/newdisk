'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var templates = angular.module("templates", []);

var coreApp = angular.module('coreApp', ['templates', 'scormwrapper',
// "com.2fdevs.videogular",
// "com.2fdevs.videogular.plugins.controls",
// "com.2fdevs.videogular.plugins.overlayplay",
// "com.2fdevs.videogular.plugins.poster",
'ngRoute', 'ui.bootstrap', 'ngAnimate', 'ngMaterial', 'ngStorage', 'ngCordova', 'ngPinchZoom'])
//add lodash to use in factories:
.constant('_', window._)
//add lodash to use in templates:
.run(['$rootScope', function ($rootScope) {
  $rootScope._ = window._;
}]);

//Before angular bootstrap ###################################
angular.element(document).ready(function () {
  if (window.cordova) {
    console.log("Running in Cordova.");
    document.addEventListener('deviceready', function () {
      preConfig();
      console.log('window.device:', window.device);
      navigator.splashscreen.hide();
    });
  } else {
    console.log("Running in browser.");
    preConfig();
  }
});

function preConfig() {
  var initInjector = angular.injector(["ng", "scormwrapper"]);
  var $http = initInjector.get("$http");
  var $q = initInjector.get("$q");
  var scormWrapper = initInjector.get("scormWrapper");
  var config = void 0;

  console.log('Loading course_config...');
  $http.get("data/course_config.json").then(function (response) {
    return config = response.data;
  }, function (error) {
    throw new Error('Failed to load course_config!');
  }).then(function () {
    console.log('Loading course_structure...');
    var structure = {
      config: config,
      courses: []
    };
    coreApp.value("$structure", structure);

    var promises = _.map(config.localizations, function (localization) {
      return $http.get("data/course_structure_" + localization + ".json").then(function (response) {
        return response.data.course;
      });
    });

    return $q.all(promises).then(function (values) {
      console.log('Localizations loaded:', values);
      structure.courses = values;
      structure.course = structure.courses[config.default_localization];
    });
  }).then(function () {
    console.log('Loading tincan_config...');

    return $http.get("data/tincan_config.json").then(function (response) {
      return coreApp.constant("$tincanConfig", response.data);
    }, function (error) {
      throw new Error('Failed to load tincan_config!');
    });
  }).then(function () {
    console.log('Try to connect to LMS...');

    //lmsConnected == true, если запуск через LMS
    // поиск API scorm с помощью плагина scormWrapper
    var lmsConnected = scormWrapper.doLMSInitialize();
    coreApp.constant("$lmsConnected", lmsConnected);

    console.log('LMS connected: ', lmsConnected);
  }).then(function () {
    console.log("Bootstrapping AngularJS...");

    angular.bootstrap(document.body, ['coreApp']);
    // подключение MathJax
    MathJax.Hub.Config({
      messageStyle: "none",
      jax: ["input/TeX", "output/HTML-CSS"],
      "HTML-CSS": {
        showMathMenu: false,
        scale: 150,
        availableFonts: ["STIX", "TeX"],
        styles: {
          ".MathJax": {
            "text-align": "center",
            margin: "1em 0em",
            "backgound-color": "transparent"
          }
        }
      }
    });

    MathJax.Hub.Configured();
  });
}

/**
 * Приблуда для безопасной загрузки ресурсов в windows8+ applications
 */
coreApp.config(['$compileProvider', function ($compileProvider) {
  return $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|ms-appx|chrome-extension|x-wmapp.?):|data:image\//);
}]);
// coreApp.config(['ChartJsProvider', ChartJsProvider =>
//   ChartJsProvider.setOptions(
//     { colors : [ '#803690',
//                   '#00ADF9',
//                   '#DCDCDC',
//                   '#46BFBD',
//                   '#FDB45C',
//                   '#949FB1',
//                   '#4D5360']
//     }
//   )
// ])

//MD - icons
coreApp.config(['$mdIconProvider', function ($mdIconProvider) {
  return $mdIconProvider.defaultFontSet('fa');
}]);

////MD - Themes
coreApp.config(['$mdThemingProvider', function ($mdThemingProvider) {
  var customPrimary = {
    '50': '#fbfbfb',
    '100': '#eeeeee',
    '200': '#e1e1e1',
    '300': '#d4d4d4',
    '400': '#c8c8c8',
    '500': '#BBB',
    '600': '#aeaeae',
    '700': '#a1a1a1',
    '800': '#959595',
    '900': '#888888',
    'A100': '#ffffff',
    'A200': '#ffffff',
    'A400': '#ffffff',
    'A700': '#7b7b7b',
    'contrastDefaultColor': 'dark', // whether, by default, text (contrast)
    // on this palette should be dark or light
    'contrastDarkColors': ['A700'],
    'contrastLightColors': undefined // could also specify this if default was 'dark'
  };

  var customAccent = {
    '50': '#340508',
    '100': '#4c070c',
    '200': '#63090f',
    '300': '#7b0b13',
    '400': '#920d17',
    '500': '#aa0f1a',
    '600': '#d81322',
    '700': '#eb1a2a',
    '800': '#ed323f',
    '900': '#ef4955',
    'A100': '#d81322',
    'A200': '#C1111E',
    'A400': '#aa0f1a',
    'A700': '#f1606b',
    'contrastDefaultColor': 'light'
  };

  var customWarn = {
    '50': '#0c887c',
    '100': '#ef4955',
    '200': '#ed323f',
    '300': '#eb1a2a',
    '400': '#d81322',
    '500': '#C1111E',
    '600': '#aa0f1a',
    '700': '#920d17',
    '800': '#7b0b13',
    '900': '#63090f',
    'A100': '#f37881',
    'A200': '#f58f97',
    'A400': '#f7a7ad',
    'A700': '#4c070c'
  };

  var customBackground = {
    '50': '#eaeaea',
    '100': '#dddddd',
    '200': '#d0d0d0',
    '300': '#c3c3c3',
    '400': '#b7b7b7',
    '500': '#aaa',
    '600': '#9d9d9d',
    '700': '#909090',
    '800': '#848484',
    '900': '#777777',
    'A100': '#f6f6f6',
    'A200': '#ffffff',
    'A400': '#ffffff',
    'A700': '#6a6a6a',
    'contrastDefaultColor': 'light'
  };

  $mdThemingProvider.definePalette('customPrimary', customPrimary);
  $mdThemingProvider.definePalette('customAccent', customAccent);
  $mdThemingProvider.definePalette('customWarn', customWarn);
  $mdThemingProvider.definePalette('customBackground', customBackground);

  $mdThemingProvider.theme('courseTheme').primaryPalette('customPrimary').accentPalette('customAccent').warnPalette('customWarn').backgroundPalette('customBackground');

  $mdThemingProvider.theme('default').primaryPalette('customPrimary').accentPalette('customAccent').warnPalette('customWarn').backgroundPalette('customBackground');

  $mdThemingProvider.theme("success-toast");
  $mdThemingProvider.theme("failed-toast");
}]);

/**
 * Created by aklimenko on 28.03.16.
 */

'use strict';

coreApp.controller('SimpleModalWinCtrl', ['$scope', '$element', 'close', 'title', 'message', function ($scope, $element, close, title, message) {

  $scope.title = title;
  $scope.message = message;

  $scope.close = function (param) {
    $element.modal('hide');
    close(param, 500); // close, but give 500ms for bootstrap to animate
  };
}]);

/**
 * Created by aklimenko on 16.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsContainer
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsContainer', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr, ctrl, transFn) {
      transFn(function (content) {
        elem.find('.crs-container').append(content);
      });
    },
    scope: {},
    //controller: 'crsContCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div ' + 'class="crs-container md-row" ' + 'layout-xs="column" ' + 'layout-gt-xs="row" ' + 'layout-align="space-around center"' + 'layout-padding-sm' + '></div>'
  };
});

/**
 * Created by aklimenko on 15.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:draggable
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('draggable', function () {
  return {
    restrict: 'A',
    link: function link(scope, elem, attr) {
      Draggable.create(elem, { type: "scroll", edgeResistance: 0.65, bounds: elem, throwProps: true });
    },
    scope: {}
  };
});

/**
 * Created by aklimenko on 23.03.2016.
 *
 * Enables to insert htmlText in field
 *
 * Usage:
 *
 * <p ng-bind-html="<b>Accelerare</b> Ecce, verpa!" html-safe></p>
 *
 * results -> "Accelerare Ecce, verpa!"
 */

coreApp.directive('htmlSafe', ['$parse', '$sce', function ($parse, $sce) {
  return {
    link: function link(scope, elem, attr) {
      var html = attr.ngBindHtml;
      if (angular.isDefined(html)) {
        var getter = $parse(html);
        var setter = getter.assign;
        setter(scope, $sce.trustAsHtml(getter(scope)));
      }
    }
  };
}]);
/**
 * Created by ralic on 06.04.2016.
 *
 * Inserts video
 */

"use strict";

coreApp.directive('htmlVideo', ['$sce', '$parse', function ($sce, $parse) {
  return {
    replace: true,
    link: function link($scope, element) {

      $scope.hasVideo = false;

      $scope.$watch(function () {
        return $scope.src;
      }, function (newSrc) {
        //if (newSrc) {
        //  $scope.hasVideo=true;
        //  element.empty();
        //}
        //else $scope.hasVideo=false;
        $scope.config = {
          sources: [{ src: $sce.trustAsResourceUrl(newSrc), type: "video/mp4" }],
          theme: {
            url: 'css/videogular.css'
          }
        };
      });
    },
    scope: {
      src: '@',
      vtype: '@',
      width: '@',
      controls: '@'
    },
    templateUrl: 'common/videogularTemplate.html'
  };
}]);
/**
 * Created by aklimenko on 14.06.2016.
 */
coreApp.directive("mathjaxBind", function () {
  return {
    restrict: "A",
    controller: ["$scope", "$element", "$attrs", function ($scope, $element, $attrs) {
      $scope.$watch($attrs.mathjaxBind, function (value) {
        var $script = angular.element("<script type='math/tex'>").html(value == undefined ? "" : value);
        $element.html("");
        $element.append($script);
        MathJax.Hub.Queue(["Reprocess", MathJax.Hub, $element[0]]);
      });
    }]
  };
});
/**
 * Created by aklimenko on 08.04.16.
 */

coreApp.animation('.slide-animation', function () {
  return {
    addClass: function addClass(element, className, done) {
      if (className == 'ng-hide') {
        TweenMax.to(element, 0.5, { left: -element.parent().width(), onComplete: done });
      } else {
        done();
      }
    },
    removeClass: function removeClass(element, className, done) {
      if (className == 'ng-hide') {
        element.removeClass('ng-hide');

        TweenMax.set(element, { left: element.parent().width() });
        TweenMax.to(element, 0.5, { left: 0, onComplete: done });
      } else {
        done();
      }
    }
  };
});
/**
 * Created by aklimenko on 30.03.16.
 *
 * Creates multiple <p> from text array
 *
 * Usage:
 * $scope.arr=['Ecce.','Our brilliant','Break me pirate, ye black sailor!'];
 *
 * <text-array strings='{{arr}}'></text-array>
 */

coreApp.directive('textArray', ['UtilityService', function (UtilityService) {
  return {
    restrict: 'EA',
    replace: true,
    link: function link($scope) {
      $scope.strings = UtilityService.textToBlockArray($scope.strings);

      $scope.$watch(function () {
        return $scope.strings;
      }, function (newVal) {
        $scope.strings = UtilityService.textToBlockArray(newVal);
      });
    },
    scope: {
      strings: '@'
    },
    template: '<p ng-repeat="block in strings track by $index" ng-bind-html="block" html-safe></p>'
  };
}]);
/**
 * Created by aklimenko on 23.03.2016.
 *
 * Default controller for all components attached to page
 * Gets component data by componentid attribute and assign
 * $scope.data to component[n].data
 *
 * It also sets $scope.classes from component[n].data.classes
 * just because it's a default option
 *
 * Uses ModalService to make components availaible to show modal windows.
 *
 */

'use strict';

coreApp.controller('ComponentCtrl', ['$scope', '$attrs', '$element', 'ModalService', 'UtilityService', '$http', function ($scope, $attrs, $element, ModalService, UtilityService, $http) {

  if ($attrs.componentid) {
    $scope.componentid = $scope.$eval($attrs.componentid);
  }

  $scope.data = $scope.page.components[$scope.componentid].data;
  $scope.classes = $scope.data.classes;

  if ($scope.page.type == 'ex') {

    // Загружаем файл с инфо по типам заданий, чтобы узнать какой тип приза получим
    // Не засовываем эту логику в сервис, тк тоже самое делаем в контроллере окна статистики

    $http.get('data/win-stats.json').then(function (response) {
      $scope.winStats = response.data;

      $scope.prize = '';
      switch ($scope.data.type) {
        case 'ex-rebus-cross':
          $scope.prize = $scope.winStats.rebusCross.prize;
          break;
        case 'ex-quiz':
          $scope.prize = $scope.winStats.quiz.prize;
          break;
        case 'ex-theory':
          $scope.prize = $scope.winStats.theory.prize;
          break;
        case 'ex-practical':
          $scope.prize = $scope.winStats.practical.prize;
          break;
        case 'ex-exercise':
          $scope.prize = $scope.winStats.exercise.prize;
          break;
        default:
          console.log('no such ex type:', $scope.data.type);
      }
    });
  }

  $scope.showTaskResultWin = function (add_msg) {
    var message = [''].concat(add_msg);
    if ($scope.data.result == 100) {
      message = message.concat($scope.data.feedback.right);
    } else {
      message = message.concat($scope.data.feedback.wrong);
    }

    ModalService.showModal({
      templateUrl: 'templates/taskModalWinTemplate.html',
      controller: 'SimpleModalWinCtrl',
      inputs: {
        score: $scope.data.result,
        prize: $scope.prize,
        title: $scope.data.result == 100 ? 'ВЕРНО' : 'НЕВЕРНО',
        message: message
      },
      scope: $scope
    }).then(function (modal) {
      modal.element.modal();
      modal.close.then(function (result) {});
    });
  };
}]);
/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsAccordion
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsAccordion', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    //controller: 'CrsAccordionCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div class="crs-accordion"><uib-accordion ' + 'template-url="components/accordion/crsAccordionTmpl.html">' + '</uib-accordion></div>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsBulletList
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsBulletList', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr, ctrl, transFn) {
      transFn(function (content) {
        elem.find('.crs-bullet-list').append(content);
      });
    },
    scope: {},
    //controller: 'CrsBulletListCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div class="crs-bullet-list"></div>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsCatalog
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsCatalog', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr, ctrl, transFn) {
      transFn(function (content) {
        elem.find('.crs-container').append(content);
      });
    },
    scope: {
      layoutXs: '@'
    },
    //controller: '',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div class="crs-catalog"><crs-container></crs-container></div>'
  };
});
/**
 * Created by aklimenko on 10.08.2016.
 * @ngdoc directive
 * @name coreApp:crsTaskCompleted
 *
 * @description
 *
 *
 * @restrict AE
 * */
angular.module('coreApp').directive('crsTaskCompleted', [function () {
  return {
    restrict: 'AE',
    scope: {},
    template: '<div class="crs-task__completed">' + 'Выполнено <i class="fa fa-check" aria-hidden="true"></i></div>'
  };
}]);

/**
 * @ngdoc directive
 * @name coreApp:crsContentTextDirective
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsContentText', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    transclude: true,
    replace: true,
    template: '<div class="crs-content-text"><ng-transclude></ng-transclude></div>'
  };
});

/**
* @author aklimenko
* @date 05.08.2016
*
*/

angular.module('coreApp').service('CrsGlossary', ['$mdDialog', function ($mdDialog) {
  this.show = function (evt) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    console.log('scale dialog', params);
    $mdDialog.show({
      controller: 'CrsGlossaryCtrl',
      templateUrl: 'components/glossary/glossaryDialogTmpl.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      clickOutsideToClose: true,
      fullscreen: true,
      locals: {
        params: params
      },
      autoWrap: false
    });
  };
  return this;
}]);

/**
* @author aklimenko
* @date 05.08.2016
*
*/

angular.module('coreApp').controller('CrsGlossaryCtrl', ['$http', '$scope', '$mdDialog', '$mdSidenav', 'UtilityService', function ($http, $scope, $mdDialog, $mdSidenav, UtilityService, params) {
  $scope.params = params;
  $scope.closeDialog = function () {
    return $mdDialog.hide();
  };
  $scope.$watch(function () {
    return $scope.searchItem;
  }, function (val) {
    UtilityService.wikiService.get(val).then(function (response) {
      $scope.fromWiki = response.data;
      $scope.isEmpty = _.some(response.data.query.pages, function (page) {
        return !page.extract;
      });
    });
  });

  $http.get("data/glossary.json").then(function (response) {
    return $scope.data = response.data;
  }, function (error) {
    throw new Error('Failed to load glossary!');
  });
}]);

/**
 * Created by aklimenko on 14.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsFormula
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsFormula', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {
      mathBind: '@',
      toCenter: '@'
    },
    //controller: 'CrsFormulaCtrl',
    controllerAs: 'ctrl',
    template: '<div class="crs-formula"><span mathjax-bind="mathBind"></span></div>'
  };
});

/**
 * Created by aklimenko on 16.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsFormulaWrapper
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsFormulaWrapper', ['$parse', function ($parse) {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {
      crsLayout: '@'
    },
    //controller: 'crsFormulaWrapperCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    replace: true,
    template: '<div class="crs-formula-wrapper table-responsive" md-colors="{background:\'primary-100\'}"  md-whiteframe="2" layout-padding ng-transclude></div>'
  };
}]);

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsImg
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsImg', ['$mdMedia', function ($mdMedia) {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {
      if (!scope.alt) scope.noImage = "image " + scope.src;

      if (scope.srcXs) scope.$watch(function () {
        return $mdMedia('xs');
      }, function (val) {
        if (val) scope.src = scope.srcXs;
      });
      if (scope.srcGtXs) scope.$watch(function () {
        return $mdMedia('gt-xs');
      }, function (val) {
        if (val) scope.src = scope.srcGtXs;
      });
      if (scope.srcSm) scope.$watch(function () {
        return $mdMedia('sm');
      }, function (val) {
        if (val) scope.src = scope.srcSm;
      });
      if (scope.srcGtSm) scope.$watch(function () {
        return $mdMedia('gt-sm');
      }, function (val) {
        if (val) scope.src = scope.srcGtSm;
      });
      if (scope.srcMd) scope.$watch(function () {
        return $mdMedia('md');
      }, function (val) {
        if (val) scope.src = scope.srcMd;
      });
      if (scope.srcGtMd) scope.$watch(function () {
        return $mdMedia('gt-md');
      }, function (val) {
        if (val) scope.src = scope.srcGtMd;
      });
      if (scope.srcLg) scope.$watch(function () {
        return $mdMedia('lg');
      }, function (val) {
        if (val) scope.src = scope.srcLg;
      });
      if (scope.srcGtLg) scope.$watch(function () {
        return $mdMedia('gt-lg');
      }, function (val) {
        if (val) scope.src = scope.srcGtLg;
      });
      if (scope.srcXl) scope.$watch(function () {
        return $mdMedia('xl');
      }, function (val) {
        if (val) scope.src = scope.srcXl;
      });
    },
    scope: {
      src: '@',
      alt: '@',
      srcXs: '@',
      srcGtXs: '@',
      srcSm: '@',
      srcGtSm: '@',
      srcMd: '@',
      srcGtMd: '@',
      srcLg: '@',
      srcGtLg: '@',
      srcXl: '@'
    },
    //controller: 'CrsImgCtrl',
    controllerAs: 'ctrl',
    template: '<div class="crs-img" md-whiteframe="2"> ' + '<img ng-src="{{src}}" alt="{{noImage}}" class="img-responsive center-block"/>' + '</div>'
  };
}]);

/**
 * Created by aklimenko on 09.06.2016.
 */
/**
 * @ngdoc directive crsPageFooterImg
 * @name coreApp:
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsPageFooterImg', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {
      src: '@'
    },
    //controller: 'CrsPageFooterImgCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div class="crs-page-footer-img" ng-style="{\'background-image\':\'url({{src}})\'}"></div>'
  };
});

/**
* Created by aklimenko on 10.08.2016.
*/

"use strict";

angular.module('coreApp').controller('CrsStaticSlideCtrl', ['$scope', 'ProgressManager', 'CrsStateService', '$mdToast', function ($scope, ProgressManager, CrsStateService, $mdToast) {
  $scope.result = CrsStateService.getCurrentComponentScore($scope.componentIndex);
  // console.log('CrsTaskCtrl page componentIndex:',$scope.componentIndex)
  $scope.$watch(function () {
    return $scope.result;
  }, function (val, oldVal) {
    if (val === oldVal) return;
    console.log('CrsPageComponentCtrl result changed:', val);
    ProgressManager.saveComponentScore($scope.result);
    $scope.result = val;
    CrsStateService.update();
  });
}]);

/**
 * Created by aklimenko on 21.06.2016.
 */
angular.module('coreApp').directive('crsStaticSlide', ['$timeout', function ($timeout) {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {

      $timeout(function () {
        scope.result = 1;
      });

      //console.log('set result from slide:', scope.result)
    },
    scope: true,
    // scope: {
    //   componentIndex:'@',
    // },
    controller: 'CrsStaticSlideCtrl',
    transclude: true,
    replace: true,
    template: '<div class="crs-static-slide"><div ng-transclude></div></div>'
  };
}]);

/**
 * @ngdoc controller
 * @name coreApp:CrsImgScaleCtrl
 *
 * @description
 *
 *
 * @requires $scope
 * */
angular.module('coreApp').controller('CrsImgScaleCtrl', ['$mdDialog', '$scope', function ($mdDialog, $scope) {
  var ctrl = this;

  ctrl.showScaleDialog = function (evt) {
    console.log('scale dialog');
    $mdDialog.show({
      controller: DialogController,
      templateUrl: 'components/image-scale/imgScaleDialogTmpl.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      clickOutsideToClose: true,
      fullscreen: true,
      locals: {
        src: $scope.src,
        title: $scope.title
      },
      autoWrap: false,
      onComplete: function onComplete(scope, elem, attr) {
        var imgH = elem.find('md-dialog').height() - elem.find('.crs-img-scale-slider').height() - elem.find('md-toolbar').height();
        TweenMax.to(elem.find('img'), .3, {
          height: imgH
        });
        elem.find('img').height();
        console.log('elem:', elem);
      }
    });

    function DialogController($scope, $mdDialog, src, title) {
      $scope.src = src;
      $scope.title = title;
      $scope.zoom = 1;

      console.log('DialogController');
      $scope.closeDialog = function () {
        $mdDialog.hide();
      };
    }
  };
}]);

/**
 * Created by aklimenko on 10.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsImgScale
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsImgScale', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {
      title: '@',
      src: '@',
      preview: '@'
    },
    controller: 'CrsImgScaleCtrl',
    controllerAs: 'ctrl',
    template: '<div class="crs-img-scale" ng-click="ctrl.showScaleDialog($event)">' + '<img src="{{preview}}" alt="image: {{preview}}" class="img-responsive thumbnail">' + '<div class="crs-img-scale-magnify md-accent fa fa-search-plus" aria-hidden="true"></div>' + '</div>'
  };
});

/**
* @author aklimenko
* @date 05.08.2016
*
*/

angular.module('coreApp').service('CrsStatistics', ['$mdDialog', function ($mdDialog) {
  this.show = function (evt) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    console.log('scale dialog', params);
    $mdDialog.show({
      controller: 'CrsStatisticsCtrl',
      controllerAs: 'ctrl',
      templateUrl: 'components/statistics/statisticsDialogTmpl.html',
      parent: angular.element(document.body),
      targetEvent: evt,
      clickOutsideToClose: true,
      fullscreen: true,
      locals: {
        params: params
      },
      autoWrap: false
    });
  };
  return this;
}]);

/**
* @author aklimenko
* @date 05.08.2016
*
*/

angular.module('coreApp').controller('CrsStatisticsCtrl', ['$scope', '$mdDialog', 'CrsStateService', '$structure', '_', function ($scope, $mdDialog, CrsStateService, $structure, _, params) {
  $scope.params = params;
  $scope.closeDialog = function () {
    return $mdDialog.hide();
  };
  this.gotoTask = function (item) {
    console.log('try to go to', item.id);
    $scope.closeDialog();
    CrsStateService.goToPageById(item.id);
  };

  $scope.$watchCollection(function () {
    return CrsStateService.get;
  }, function () {
    $scope.pages = CrsStateService.get.pages;
    $scope.currentPageNumber = CrsStateService.get.currentPageNumber;
    // console.log('main menu watch')
    var num_right = 0;
    var num_na = 0;
    var num_wrong = 0;

    $scope.tasks = _.chain($structure.course.chapters).map(function (ch, i) {
      return _.map(ch.pages, function (pg, j) {
        _.forEach(pg.components, function (c, k) {
          //yes, I know it's a MESS
          c.score = CrsStateService.get.progress.state[i][j].scores[k];
        });
        return pg;
      });
    }).flatten().filter(function (pg) {
      return pg.type == 'ex';
    }).forEach(function (page) {
      // console.log('page updated:',page);
      num_right += _.filter(page.components, function (c) {
        return c.score == 1;
      }).length;
      num_na += _.filter(page.components, function (c) {
        return c.score == -1;
      }).length;
      num_wrong += _.filter(page.components, function (c) {
        return c.score != -1 && c.score < 1;
      }).length;
      page.hasPassed = page.hasNA = page.hasNotPassed = false;

      _.forEach(page.components, function (component) {
        page.hasPassed = page.hasPassed || component.score == 1; //ex has passed comps
        page.hasNA = page.hasNA || component.score == -1; //ex has not answered comps
        page.hasNotPassed = page.hasNotPassed || component.score != -1 && component.score < 1; //ex has not passed comps
      });
    }).value();
    $scope.labels = ['Верно', 'Не выполнено', 'Неверно'];
    $scope.data = [num_right, num_na, num_wrong];
    $scope.taskCompleted = num_right;
  });
}]);

/**
 * Created by User on 6/16/2016.
 */
/**
 * @ngdoc directive crsTable
 * @name coreApp:
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsTable', ['$compile', function ($compile) {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {
      elem.find('table').addClass('table ');
      elem.find('td').attr('md-colors', "{background: 'primary-100'}");
      elem.find('th').attr('md-colors', "{background: 'primary-400'}");
      $compile(elem.find('table'))(scope);
    },
    scope: {
      src: '@'
    },
    //controller: 'CrsTableCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    replace: true,
    template: '<div class="crs-table table-responsive" ng-transclude></div>'
  };
}]);

/**
 * Created by aklimenko on 10.08.2016.
 */

"use strict";

angular.module('coreApp').controller('CrsTaskCtrl', ['$scope', 'ProgressManager', 'CrsStateService', '$mdToast', "$mdDialog", function ($scope, ProgressManager, CrsStateService, $mdToast, $mdDialog) {

  var answerFeedbacks = [$scope.incorrectAnswer0, $scope.incorrectAnswer1, $scope.incorrectAnswer2];

  var incorrectAnsCounter = 0; //counts incorrect answers

  $scope.result = CrsStateService.getCurrentComponentScore($scope.componentIndex);

  //$scope.isEvenSSS = function() { return true};
  $scope.showAlert = function (ev) {
    console.info(" $scope.showAlert 1");
    // Appending dialog to document.body to cover sidenav in docs app
    // Modal dialogs should fully cover application
    // to prevent interaction outside of dialog
    $mdDialog.show($mdDialog.alert().parent(angular.element(document.querySelector('#popupContainer'))).clickOutsideToClose(true).title('This is an alert title').textContent('You can specify some description text in here.').ariaLabel('Alert Dialog Demo').ok('Got it!').targetEvent(ev));
  };

  $scope.openOffscreen = function () {
    $mdDialog.show($mdDialog.alert()
    //.id = ttt
    .clickOutsideToClose(true).theme('failed-dialog')
    // .primaryPalette('purple')
    .title('').textContent(answerFeedbacks[incorrectAnsCounter - 1]).ariaLabel('Offscreen Demo').ok('Закрыть')
    // Or you can specify the rect to do the transition from
    .openFrom({
      top: -50,
      width: 30,
      height: 80
    }).closeTo({
      left: 1500
    }));
  };

  // console.log('CrsTaskCtrl page componentIndex:',$scope.componentIndex)
  $scope.changeResult = function (val) {

    console.info("$scope.changeResult-1");

    //console.log('Функция - scope.changeResult!!!!!!!',$scope.rightAnswerShow);

    // console.log('CrsTaskCtrl result changed:',val,'|',oldVal);
    // if (val == -1 || val==oldVal ) return;
    ProgressManager.saveComponentScore($scope.result);
    $scope.result = val;
    CrsStateService.update();

    if ($scope.result == 1) {
      incorrectAnsCounter = 0;
      $scope.isFailed = false;
      $scope.isVisibDiv1 = true;
      $scope.isVisibDiv2 = false;

      $mdToast.show($mdToast.simple().textContent($scope.correctAnswer).theme('success-toast')
      //hideDelay - длительность показа окна
      .hideDelay(3000));
    } else if ($scope.result >= 0) {
      incorrectAnsCounter++;

      //показываем тост снизу с коментариями на неправильные ответы
      /* $mdToast.show(
        $mdToast.simple()
           .textContent(answerFeedbacks[incorrectAnsCounter-1])
           .theme('failed-toast')
           .hideDelay($scope.hideDelayTime||3000)
       );*/

      //показываем модальное окно с коментариями на неправильные ответы

      $scope.openOffscreen();

      if (incorrectAnsCounter >= $scope.attempts) {
        incorrectAnsCounter = 0;
        $scope.isFailed = true;
        $scope.isVisibDiv1 = false;
        $scope.isVisibDiv2 = true;

        if ($scope.deactivateButton) $scope.deactivateButton();
        if ($scope.isEvenSSS) $scope.isEvenSSS();
        if ($scope.showRightAnswer) $scope.showRightAnswer();
      }
    }
  };
}]);
//***************************************


/**
 * Created by ppodgorny on 06.10.2016.
 */

/* angular.module('coreApp')

 .controller('AppCtrl', function($scope, $mdDialog) {
    $scope.openFromLeft = function() {
      $mdDialog.show(
        $mdDialog.alert()
          .clickOutsideToClose(true)
          .title('Opening from the left')
          .textContent('Closing to the right!')
          .ariaLabel('Left to right demo')
          .ok('Nice!')
          // You can specify either sting with query selector
          .openFrom('#left')
          // or an element
          .closeTo(angular.element(document.querySelector('#right')))
      );
    };

    $scope.openOffscreen = function() {
      $mdDialog.show(
        $mdDialog.alert()
          .clickOutsideToClose(true)
          .title('Opening from offscreen')
          .textContent('Closing to offscreen')
          .ariaLabel('Offscreen Demo')
          .ok('Amazing!')
          // Or you can specify the rect to do the transition from
          .openFrom({
            top: -50,
            width: 30,
            height: 80
          })
          .closeTo({
            left: 1500
          })
      );
    };
  });











/**
 * Created by aklimenko on 21.03.16.
 *
 * Component shows pictures and navigation buttons
 * When user clicks a button picture and text changes
 *
 * Data example:
 * {
 *   component: 'slider',
 *   data: {
 *     images:[
 *       {
 *         src:'img/img0.png',
 *         text:['sweet <b>chili</b> <i>sauce1</i>','Always purely realize the mysterious lord. ']
 *       },
 *       {
 *         src:'img/img1.png',
 *         text:'<b>Golly</b> gosh, real love!'
 *       },
 *     ],
 *     classes: "",
 *     css: {}
 *   }
 *  }
 */

'use strict';

coreApp.controller('SliderController', ['$scope', 'UtilityService', '$sce', function ($scope, UtilityService, $sce) {

  $scope.images = $scope.data.images;
  $scope.currentItem = null;

  $scope.showSlide = function (num) {
    $scope.num = num;
    $scope.images[num].passed = true;
    $scope.images[num].text = UtilityService.textToBlockArray($scope.images[num].text);

    //console.log('text:', $scope.images[num].text)
    $scope.currentItem = $scope.images[num];
  };

  $scope.showSlide(0);

  $scope.hasText = function (index) {
    return $scope.images[index].text[0] != '';
  };
}]);

coreApp.directive('slider', ['$compile', function ($compile) {

  return {
    restrict: 'EA',
    replace: true,
    scope: true,
    link: function link(scope, element) {

      //var $v =$('<html-video data-src="{{images[num].video}}" data-width="100%" data-controls="true"></html-video>')
      //scope.$watch(function(){return scope.currentItem}, function(newVal){
      //  var $v = element.find('video').clone();
      //  element.find('video').remove();
      //  element.find('html-video').append($v)
      //  $compile(element.find('slider-slide').contents())(scope);
      //  //element.find('slider-slide').append($compile(element.find('html-video').contents())(scope));
      //})
    },
    controller: 'SliderController as controller',
    templateUrl: 'page_components/interactive/sliderTemplate.html'
  };
}]);

/**
 * Created by aklimenko on 23.03.2016.
 */
'use strict';

coreApp.controller('ImageCatalogController', ['$scope', 'UtilityService', function ($scope, UtilityService) {

  $scope.items = $scope.data.images;
  $scope.sharedText = UtilityService.textToBlockArray($scope.data.sharedText || '');

  if ($scope.items.length > 2) {
    $scope.itemBootstrapColumn = 'col-sm-4';
  } else if ($scope.items.length == 2) {
    $scope.itemBootstrapColumn = 'col-sm-6';
  } else {
    $scope.itemBootstrapColumn = 'col-sm-12';
  }

  $.each($scope.items, function (index, item) {
    item.text = UtilityService.textToBlockArray(item.text);
  });

  $scope.getCols = function (index) {
    var row = index + 1;

    if (row % 6 == 0) {
      return 6;
    } else if (row % 2 == 0) {
      return 2;
    } else if (row % 3 == 0) {
      return 3;
    }

    return 1;
  };

  $scope.hasText = function (index) {
    return $scope.items[index].text[0] != '';
  };
}]);

coreApp.directive('imageCatalog', function () {
  return {
    restrict: 'EA',
    replace: false,
    scope: true,
    controller: 'ImageCatalogController',
    templateUrl: 'page_components/static/imageCatalogTemplate.html'
  };
});
/**
 * Created by aklimenko on 07.04.16.
 *
 * Loads external page without task and send/get results
 */

'use strict';

coreApp.controller('pageExternalController', ['$scope', '$element', '$sce', function ($scope, $element, $sce) {
  $scope.url = $sce.trustAsResourceUrl($scope.data.url);
}]);

coreApp.directive('pageExternal', ['$window', function ($window) {

  function linker($scope, $element) {

    var $frame = $element.find('iframe');

    $frame.css('width', '100%');

    $frame.bind('load', function (event) {
      $scope.onFrameLoaded();
    });

    $scope.onFrameLoaded = function () {
      //console.log('frame loaded')
      setFrameSize();

      $($window).on('resize', function () {
        setFrameSize();
      });

      function setFrameSize() {
        $element.find('iframe').contents().find('body').width($element.width()).css('margin', '0').css('padding', '0');
      }
      $frame.iFrameResize({
        checkOrigin: false
      });
    };
  }

  return {
    restrict: 'EA',
    replace: false,
    scope: true,
    link: linker,
    controller: 'pageExternalController',
    template: '<div class="separate-page"><iframe class="page-frame" ng-src="{{url}}">Oups...nothing here :(</iframe></div>'
  };
}]);
/**
 * Created by aklimenko on 22.03.2016.
 *
 * Shows bubble with htmlText
 * has stiles for addition classes:
 * -hint
 * -warn
 *
 * Data example:
 * {
 *   component: 'text-bubble',
 *   data: {
 *     text: "Teleporters fly with <b>resistance</b> at the reliable space station!",
 *     classes: "hint info",
 *     css: {}
 *   }
 * }
 *
 */

'use strict';

coreApp.directive('textBubble', ['UtilityService', function (UtilityService) {

  var linker = function linker(scope) {
    scope.renderedText = UtilityService.textToBlockArray(scope.text);
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: false,
    scope: {
      text: "@"
    },
    template: '<div class="bubble {{ classes }}">' + '<div class="hint-text">' + '<p ng-repeat="block in renderedText" ng-bind-html="block" html-safe></p>' + '</div>' + '</div>'
  };
}]);

/**
 * Created by aklimenko on 21.03.16.
 *
 * Shows dialog bubble with image and htmlText(image like a person saying something.)
 *
 * Data example:
 * {
 *   component: 'text-bubble-dialog',
 *   data: {
 *     text: "Death ho! blow to be <b>drinked</b>.",
 *     classes: "hint info",
 *     css: {}
 *   }
 * }
 *
 */

'use strict';

coreApp.directive('textBubbleDialog', ['UtilityService', function (UtilityService) {

  var linker = function linker($scope) {
    $scope.text = UtilityService.textToBlockArray($scope.data.text);
    $scope.isCollapsed = false;
    var message = $scope.text;
    $scope.$on('component_feedback', function (e, data) {
      $scope.text = data;
    });
    $scope.$on('component_reset', function (e, data) {
      $scope.text = message;
    });
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: false,
    scope: true,
    template: '<div class="bubble-dialog {{classes}}">' + '<div class="bubble-text">' + '<img ng-click="isCollapsed = !isCollapsed" ng-src="img/petruchio.png" alt="">' + '<div class="p-wrap" >' + '<text-array strings="text"></text-array>' + '</div>' + '</div>' + '</div>'
  };
}]);

/**
 * Created by aklimenko on 23.12.15.
 */

coreApp.directive('taskDrag', ['$compile', function ($compile) {

  var getTemplate = function getTemplate(variants, classes, result, even) {

    var variants_arr = [];
    var baskets_arr = [];

    for (var i = 0; i < variants.length; i++) {
      var basket = variants[i];
      //basket.name basket.content[i].text basket.content[i].img
      for (var j = 0; j < basket.content.length; j++) {
        var txt = basket.content[j].text || '';
        var img_src = basket.content[j].img || '';
        if (txt != '') txt = '<div class="var__txt">' + txt + '</div>';
        if (img_src != '') img_src = '<div class="var__img"><img src="' + img_src + '"/></div>';

        variants_arr.push('<div class="variant">' + img_src + txt + '</div>');
      }

      baskets_arr.push('<div class="basket"><div class="basket__title">' + basket.name + '</div> <div class="basket__content"></div> </div>');
    }

    return '<div class="' + classes + '">' + '<div class="drag-zone">' + '<div class="task__variants"><div class="clone-container"><div class="scroll-box">' + variants_arr.join('') + '</div></div></div>' + '<div class="task__baskets">' + baskets_arr.join('') + '</div>' + '</div>' + '<button class="task__btn btn--answer">Принять ответ</button>' + '<button class="task__btn btn--repeat">Повторить</button>' + '</div>';
  };

  var is_touch_device = function is_touch_device() {
    return !!('ontouchstart' in window);
  };

  var linker = function linker($scope, $element, $attrs) {
    if ($attrs.componentid) {
      $scope.componentid = $scope.$eval($attrs.componentid);
    }

    //=================================================
    //var _data = $scope.page.components[$scope.componentid].data;
    var _data = $scope.data;
    var _answer = _data.variants;
    var _variants = _data.variants;
    var _even = $scope.even;

    _data.result = _data.result || 0;
    _data.attempts = _data.attempts || 0; //кол-во попыток - если не было задано изначально, то 0

    $element.html(getTemplate(_variants, _data.classes, _data.result, $scope.even));

    if (_data.css != undefined) $($element).css(_data.css);

    _data.resultWin = {
      title: 'Нет ответа',
      text: "No Job!"
    };

    function rebuild() {
      $compile($element.contents())($scope);
    }

    function toggleModal(param) {

      switch (param) {
        case 'show':
          $($element).find('.ex-modal').modal('show');
          break;
        case 'hide':
          $($element).find('.ex-modal').modal('hide');
          break;
        default:
          alert('no such param');
      }
    }

    var modal = '<ex-modal-win title="data.resultWin.title" text="data.resultWin.text"></ex-modal-win>';
    var e = $compile(modal)($scope);
    $($element).append(modal);

    //====================================================================================
    //Логика задания======================================================================
    //Таскалка - растащить мячи по корзинам


    var _click = is_touch_device() ? 'touchstart' : 'click';
    var _click_end = is_touch_device() ? 'touchend' : 'click';

    var _btnAnswer = $($element).find('.btn--answer');
    var _btnRepeat = $($element).find('.btn--repeat');
    _variants = $($element).find('.variant');

    var _items = _variants.find('.variant');
    var _baskets = $($element).find('.basket');

    var animating = false;
    var _tiles;

    _items.each(function (index) {
      $(this).attrs('ans-id', index);
    });

    /**
     * инициализация
     */
    init(); //инициализация
    function init() {
      rebuild();
      $($element).find('.clone').remove();
      _tiles = [];

      // Shuffle all list items within a list:
      _variants = $($element).find('.variant');
      //_variants.shuffle();
      //_variants = $($element).find('.variant');

      _baskets = $($element).find('.basket');
      _variants.removeClass('disabled');
      _baskets.removeClass('disabled');

      _btnAnswer.addClass('disabled');
      _btnAnswer.off(_click, check);

      _btnRepeat.addClass('disabled');
      _btnRepeat.off(_click, init);

      var _max_var_width = _baskets.eq(0).width();

      //================================================================================

      var container = $($element).find('.clone-container');
      var itemCont = $($element).find('.scroll-box');
      var dropPanel = $($element).find('.task__baskets .basket');
      _items = _variants;
      var threshold = "50%";

      _items.each(function (i, element) {

        var item = $(this);
        var wrapper = item.parent();
        var clone = item.clone().addClass("clone");

        var tile = {
          clone: Math.random() > .5 ? clone.appendTo(container) : clone.prependTo(container),
          element: item,
          wrapper: container,
          dropped: false,
          moved: false,
          id: i,
          basket: -1
        };

        tile.clone.css('max-width', _max_var_width + 'px');

        _tiles.push(tile);

        tile.draggable = createDraggable(tile);

        tile.clone.on("mousedown touchstart", tile, startDraggable);
      });

      // GET POSITION ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      /**
       *
       * @param wrapper
       * @param offset
       * @returns {{x: *, y: *}}
       */
      function getPosition(wrapper, offset) {

        var wrap_pos = wrapper.offset();
        var cont_pos = container.offset();

        return {
          x: wrap_pos.left - cont_pos.left + offset.left,
          y: wrap_pos.top - cont_pos.top + offset.top
        };
      }

      // START DRAGGABLE :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      function startDraggable(event) {
        //console.log('dragTask: startDraggable');

        var tile = event.data;

        tile.clone.css('max-width', _max_var_width + 'px');

        if (tile.dropped) {
          $($element).find('.task__baskets').css('z-index', 2);
          $($element).find('.task__variants').css('z-index', 1);
        } else {
          $($element).find('.task__baskets').css('z-index', 1);
          $($element).find('.task__variants').css('z-index', 2);
        }

        tile.draggable.startDrag(event.originalEvent);
      }

      // CREATE DRAGGABLE ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      function createDraggable(tile) {
        //console.log('dragTask: createDraggable');

        var clone = tile.clone;
        var wrapper = tile.wrapper;

        //create draggable object
        tile.draggable = new Draggable(clone, {
          onPress: setActive,
          onDrag: collapseSpace,
          onRelease: dropTile
        });

        return tile.draggable;

        /**
         * on cloned item press handler
         */
        function setActive() {
          //console.log('dragTask: setActive');

          TweenLite.to(clone, 0.15, { scale: 1.2, autoAlpha: 0.75 });
        }

        /**
         * on drag -> check collapse
         */
        function collapseSpace() {
          //console.log('dragTask: collapseSpace');

          if (!tile.moved) {
            if (!this.hitTest(wrapper)) {
              tile.moved = true;
              //TODO: check collapse
              //TweenLite.to(wrapper, 0.3, { width: 0 });
            }
          }
        }

        /**
         * on drop
         */
        function dropTile() {
          //console.log('dragTask: dropTile');

          var className = undefined;
          var hit = false;

          dropPanel.each(function (index) {
            if (tile.draggable.hitTest($(this), threshold)) {

              clone.appendTo($(this).find('.basket__content'));
              tile.dropped = true;
              tile.basket = index;
              hit = true;

              //animate placing in basket
              TweenLite.to(clone, 0, { scale: 1, autoAlpha: 1, x: 0, y: 0 });

              className = "+=dropped";

              clone.css('max-width', '');
              return;
            }
          });

          if (!hit) moveBack(tile, className);

          _btnRepeat.removeClass('disabled');
          _btnRepeat.one(_click, init);

          if (isAllPlaced()) {
            _btnAnswer.removeClass('disabled');
            _btnAnswer.one(_click, check);
          } else {
            _btnAnswer.addClass('disabled');
            _btnAnswer.off(_click, check);
          }
        }
      }

      function isAllPlaced() {

        for (var i = 0; i < _tiles.length; i++) {
          if (_tiles[i].basket == -1) return false;
        }

        return true;
      }
      // MOVE BACK :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      /**
       * on miss basket
       * @param tile
       * @param className
       */
      function moveBack(tile, className) {
        //console.log('dragTask: moveBack ', tile);
        tile.dropped = false;
        tile.basket = -1;
        var clone = tile.clone;
        var element = tile.element;
        var wrapper = tile.wrapper;

        clone.appendTo(wrapper);

        //animate placing in wrapper
        TweenLite.to(clone, 0, { scale: 1, autoAlpha: 1, onComplete: done, x: 0, y: 0 });

        if (className) TweenLite.to([element, clone], 0.3, { className: className });

        function done() {
          tile.moved = false;
        }
      }

      $($element).find('.ex-modal').modal('hide');
      toggleModal('hide');
      animating = false;
    }

    /**
     * Проверка результата
     * @returns {number}
     */
    function check(e) {
      e.stopImmediatePropagation();

      $(_tiles).each(function () {
        //console.log($(this));
        $(this)[0].draggable.disable();
      });

      //console.log('check')
      _btnAnswer.addClass('disabled');
      _btnAnswer.off(_click, check);

      _btnRepeat.on(_click, init);
      _btnRepeat.removeClass('disabled');

      _variants = $($element).find('.variant');
      _variants.addClass('disabled');

      var res = 0;

      var counter = 0;
      for (var i = 0; i < _answer.length; i++) {
        _answer[i].indexes = [];
        for (var j = 0; j < _answer[i].content.length; j++) {
          _answer[i].indexes.push(counter);
          counter++;
        }
      }

      $(_tiles).each(function () {
        var tile = $(this)[0];
        var bask_id = tile.basket;

        //console.log('tile: ',tile)
        //console.log('indexOf: ',_answer[bask_id].indexes.indexOf(tile.id));
        //console.log('_answer: ',_answer);

        if (bask_id != -1 && _answer[bask_id].indexes.indexOf(tile.id) != -1) {
          res += 100 / _tiles.length;
        } else {
          res -= 100 / _tiles.length;
        }
      });

      console.info('result:', res);
      res < 0 ? res = 0 : res = Math.round(res);

      _data.result = res;
      _data.attempts++;

      if (_data.result == 100) {
        _data.resultWin.title = 'ВЕРНО';
        _data.resultWin.text = _data.feedback.right;
      } else {
        _data.resultWin.title = 'НЕВЕРНО';
        _data.resultWin.text = _data.feedback.wrong;
      }
      $scope.$emit('change_result', { result: _data.result });

      rebuild();
      //TODO: Разобраться с рендерингом директив===========================
      //$($element).find('ex-modal-win').replaceWith($compile(modal)($scope));

      toggleModal('show');

      return res;
    }
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: true,
    scope: {
      data: "=",
      even: "="
    }
  };
}]);

/**
 * Created by aklimenko on 21.01.16.
 */

coreApp.directive('taskForm', ['$compile', function ($compile) {

  var getTemplate = function getTemplate(variants, classes, result, even, page, presave_info) {

    var $template = $('<div>');

    //Основной компонент задания---------------------------------------------------
    var $component = $('<div>');
    $component.addClass(classes);

    var ans_id = 0;

    //Контейнер форм---------------------------------------------------------------
    var $list = $('<div>');
    $list.addClass('form-container');

    for (var i = 0; i < variants.length; i++) {

      //Форма по объекту из массива component->data->variants----------------------
      var $form = $('<form>');
      $form.addClass('task__variants row ');
      $form.attr({
        "num": i,
        "form-id": page.id + '_' + i
      });

      for (var j = 0; j < variants[i].fields.length; j++) {
        var field = variants[i].fields[j];

        //Контейнер для полей ввода - содержит заголовок, поле ввода и поле ошибки--
        var $field_group = $('<div>');
        $field_group.addClass('form--field--group variant col-xs-12');

        //Заголовок поля ввода------------------------------------------------------
        var $field_label = $('<div>');
        $field_label.addClass('form--field__label col-xs-12');
        $field_label.text(field.label);

        //Поле ввода----------------------------------------------------------------
        var $input_field = field.name == 'esse' ? $('<textarea>') : $('<input>');
        $input_field.addClass('form--field ');
        $input_field.attr({
          "num": j,
          "ng-model": "data.user_answer[" + i + "][" + j + "]",
          "ans-id": ans_id,
          "placeholder": field.placeholder,
          "name": field.name,
          "value": field.value
        });
        $input_field.prop('required', field.required == "true");
        //$input_field.append(field.value);
        //console.log('getTemplate: ', field.value);

        if (!field.classes) field.classes = ' ';
        var $input_wrapper = $("<div class='col-xs-12 " + field.classes + "'>");
        $input_wrapper.append($input_field);

        //Поле ошибки---------------------------------------------------------------
        //var $error_msg = $('<div>');
        //if (field.required) {
        //  var default_error_msg = 'Заполните поле';
        //  $error_msg.addClass('error-input');
        //  $error_msg.text(field.error || default_error_msg);
        //}

        //Добавляем в заголовок, поле ввода и поле ошибки в контейнер полей ввода---
        $field_group.append($field_label, $input_wrapper /*, $error_msg*/);

        //Добавляем контейнер полей ввода в форму-----------------------------------
        $form.append($field_group);

        ans_id++;
      }
      //Добавляем форму в компонент-------------------------------------------------
      $component.append($form);

      //Добавляем инфо перед кнопками-----------------------------------------------
      if (presave_info) {
        var $presaveInfo = $('<div>');
        $presaveInfo.addClass('presave-info');
        $presaveInfo.text(presave_info);
        $component.append($presaveInfo);
      }
    }

    //Кнопка сохранить--------------------------------------------------------------
    var $btn_answer = $('<button class="task__btn btn--answer">Сохранить</button>');

    //Кнопка очистить---------------------------------------------------------------
    var $btn_repeat = $('<button class="task__btn btn--repeat">Очистить</button>');

    //Заполняем компонент и возвращаем заготовку------------------------------------
    $component.append($btn_answer);
    $component.append($btn_repeat);
    $template.append($component);

    return $template.html();
  };

  var is_touch_device = function is_touch_device() {
    return !!('ontouchstart' in window);
  };

  var linker = function linker($scope, $element, $attrs) {
    if ($attrs.componentid) {
      $scope.componentid = $scope.$eval($attrs.componentid);
    }

    //=================================================
    //var _data = $scope.page.components[$scope.componentid].data;
    var _data = $scope.data;
    _data.result = _data.result || 0;
    _data.presave_info = _data.presave_info || '';
    _data.attempts = _data.attempts || 0; //кол-во попыток - если не было задано изначально, то 0

    //take answers from component
    var _answer = [];
    var ans_id = 0;

    if (!_data.variants) return;

    for (var i = 0; i < _data.variants.length; i++) {
      for (var j = 0; j < _data.variants[i].fields.length; j++) {
        var field = _data.variants[i].fields[j];

        if (field.answer) {
          _answer.push({
            id: ans_id,
            answer: field.answer
          });
        }

        ans_id++;
      }
    }

    var modal = '<ex-modal-win title="data.resultWin.title" text="data.resultWin.text"></ex-modal-win>';

    _data.resultWin = {
      title: 'Нет ответа',
      text: "No Job!"
    };

    function createFromTemplate() {
      $element.html(getTemplate(_data.variants, _data.classes, _data.result, $scope.even, $scope.page, _data.presave_info));
      if (_data.css != undefined) $($element).css(_data.css);

      $compile(modal)($scope);
      $($element).append(modal);
    }

    function rebuild() {
      $compile($element.contents())($scope);
      addMask();
      //console.log('rebuilded!======================================')
    }

    function addMask() {
      //mask======================
      var $date = $($element).find('[name="date"]');
      var $email = $($element).find('[name="email"]');
      var $tel = $($element).find('[name="tel"]');
      var $name = $($element).find('[name="name"]');
      $date.inputmask('date');
      $email.inputmask('email');
      $tel.inputmask('+9 (999) 999-99-99');
    }

    function toggleModal(param) {

      switch (param) {
        case 'show':
          $($element).find('.ex-modal').modal('show');
          break;
        case 'hide':
          $($element).find('.ex-modal').modal('hide');
          break;
        default:
          alert('no such param');
      }
    }

    //====================================================================================
    //Логика задания======================================================================
    //Форма - заполнить и отправить

    var _click = is_touch_device() ? 'touchstart' : 'click';
    var _click_end = is_touch_device() ? 'touchend' : 'click';

    var _btnAnswer = $($element).find('.btn--answer');
    var _btnRepeat = $($element).find('.btn--repeat');
    _variants = $($element).find('.variant');

    //отправка данных по сохранению полей
    //получение данных по изменению полей с соответствуюими идентификаторами

    $scope.$on('update_form', onUpdateForm);

    function onUpdateForm(event, $$variants) {

      //console.log('update_form:', $$variants);
      var has_updates = false;

      for (var i = 0; i < _data.variants.length; i++) {
        for (var j = 0; j < $$variants.length; j++) {
          //console.log('form_id:', _data.variants[i].form_id);

          if ($$variants[j].form_id == _data.variants[i].form_id) {
            has_updates = true;
            _data.user_answer[i] = [];
            _data.variants[i] = $$variants[j];
            for (var k = 0; k < $$variants[j].fields.length; k++) {
              _data.user_answer[i].push($$variants[j].fields[k].value);
            }
          }
        }
      }
      if (!has_updates) return;

      createFromTemplate();
      //console.log('rebuild on update...')
      rebuild();

      _variants = $($element).find('.variant');
      _btnAnswer = $($element).find('.btn--answer');
      _btnRepeat = $($element).find('.btn--repeat');

      _btnRepeat.removeClass('disabled');
      _btnRepeat.one(_click, reset);

      if (_data.save_to_file) {
        _variants.find('input').prop("disabled", false);
        _variants.removeClass('disabled');
        _variants.removeClass('selected');
        _variants.on('input', onChange);
        if (validate('onupdate')) {
          _btnAnswer.on(_click, check);
          _btnAnswer.removeClass('disabled');
        } else {
          _btnAnswer.off(_click, check);
          _btnAnswer.addClass('disabled');
        }
      } else {
        _variants.find('input').prop("disabled", true);
        _variants.addClass('disabled');
        _btnAnswer.off(_click, check);
        _btnAnswer.addClass('disabled');

        _data.attempts++;
        _data.result = 100;
        $scope.$emit('change_result', { result: _data.result });
      }

      // $scope.$apply();
    }

    /**
     * инициализация
     */
    $scope.data.user_answer = [];
    createFromTemplate();
    init(); //инициализация
    function init() {
      //console.log('formTask: init() -------')
      rebuild();

      //активируем поля
      _variants = $($element).find('.variant');
      _variants.find('input').prop("disabled", false);
      _variants.removeClass('disabled');
      _variants.removeClass('selected');
      _variants.on('input', onChange);

      //деактивируем кнопки
      _btnAnswer = $($element).find('.btn--answer');
      _btnRepeat = $($element).find('.btn--repeat');
      _btnAnswer.off(_click, check);
      _btnAnswer.addClass('disabled');
      _btnRepeat.off(_click, reset);
      _btnRepeat.addClass('disabled');

      //прячем модальное окно
      $($element).find('.ex-modal').modal('hide');
      toggleModal('hide');
    }

    function reset() {
      $($element).find('.form--field').val('');
      _data.user_answer = [];
      init();
    }

    /**
     * Ввод значения
     * @param e
     */
    function onChange(e) {
      var current = $(e.target);
      current.parent().removeClass('error');

      _btnRepeat.removeClass('disabled');
      _btnRepeat.one(_click, reset);

      if (validate()) {
        _btnAnswer.on(_click, check);
        _btnAnswer.removeClass('disabled');
      } else {
        _btnAnswer.off(_click, check);
        _btnAnswer.addClass('disabled');
      }
    }

    /**
     * поля с required='true' - проходят валидацию на заполненность
     * поля с required='false' или без required - валидацию не проходят и могут остаться пустыми
     */

    function validate(showErrors) {
      var valid = true;
      _variants = $($element).find('.variant');
      //console.log('message: ', showErrors);
      //console.log('validate: ', _variants);

      _variants.find('.form--field[required]').each(function (index) {
        //console.log('field validating...-----------',$(this))
        //console.log('val:',$(this).val());
        //console.log('val:',$(this)[0].value);
        //console.log('attr val:',$(this).attr('value'));
        if (!$(this).attr('value') && !$(this).val()) {
          valid = false;
          //console.log('Fill the field', $(this), 'valll=>',$(this).val());
        } else {
            //console.log('field valid!-----------')
          }
      });

      return valid;
    }

    function showErrors(show) {

      _variants = $($element).find('.variant');
      _variants.find('.form--field[required]').each(function () {
        if (show && $(this).val() == '') {
          $(this).parent().addClass('error');
        } else {
          $(this).parent().removeClass('error');
        }
      });
    }

    /**
     * Проверка результата
     * @returns {number}
     */
    function check(e) {

      e.stopImmediatePropagation();
      //console.log('check')

      if (!validate()) {
        showErrors(true);
        $scope.$emit('goto', { target: $($element).find('.error') });
        return null;
      }

      _btnAnswer.addClass('disabled');
      _btnAnswer.off(_click, check);

      _variants.find('input').prop("disabled", true);
      _variants.addClass('disabled');

      /*
       поля с answer='' - проходят проверку на соответствие ответу и вляют на балл
       поля без answer='' - отправляются в любом случае, но не влияют на оценку
       */

      var res = 0;
      //console.log('answers: ', _answer);
      //console.log('user_ans: ', $scope.data.user_answer);
      //найти кол-во ответов, которые нужно дать
      _variants.find('.form--field[ans-id][required]').each(function () {

        var ans_id = $(this).attr('ans-id');
        var ans = $.grep(_answer, function (e) {
          return e.id == ans_id;
        });

        if (!ans[0]) return;

        var user_ans = $(this).val();
        if (ans[0].answer == user_ans) {
          res += 100 / _answer.length;
        } else {
          res -= 100 / _answer.length;
        }
      });

      if (_answer.length == 0) res = 100; //если нет полей с ответами, то 100 баллов за отправку поля

      res < 0 ? res = 0 : res = Math.round(res);

      _data.result = res;
      _data.attempts++;

      //Сохраняем результат в структуру-----------------------------------------------------
      for (var i = 0; i < _data.variants.length; i++) {
        var frm = _data.variants[i];

        for (var j = 0; j < frm.fields.length; j++) {
          var fld = frm.fields[j];
          var type = fld.name == 'esse' ? 'textarea' : 'input';
          fld.value = $($element).find('form:nth-child(' + (i + 1) + ')').find('.form--field--group:nth-child(' + (j + 1) + ')').find(type).val();
        }
      }

      if (_data.result == 100) {
        _data.resultWin.title = 'ВЕРНО';
        _data.resultWin.text = _data.feedback.right;
      } else {
        _data.resultWin.title = 'НЕВЕРНО';
        _data.resultWin.text = _data.feedback.wrong;
      }

      //console.log('result: ', _data.result);

      $scope.$emit('change_form', _data.variants); //отправка данных об изменении полей

      $scope.$on('update_form', onUpdateForm);

      $scope.$emit('change_result', { result: _data.result }); //отправка данных об изменении результата


      //console.log('rebuild on answer')
      rebuild();
      //TODO: Разобраться с рендерингом директив===========================
      //$($element).find('ex-modal-win').replaceWith($compile(modal)($scope));

      toggleModal('show');

      if (_data.save_to_file) {
        saveToFile();
      }
      return res;
    }

    function saveToFile() {
      var info = [];
      var $inputs = $($element).find('.form--field');
      var $txt = $('<div>');

      $inputs.each(function () {
        info.push($(this).parent().prev('.form--field__label').text() + ': ' + $(this).val() + '\r\n');
      });

      for (var i = 0; i < info.length; i++) {
        $txt.append(info[i]);
      }

      console.log('txt:', $txt);

      var blob = new Blob(info, { type: "text/plain;charset=utf-8" });
      saveAs(blob, _data.file_name + ".txt");
      //$txt.wordExport();
    }
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: true,
    scope: {
      data: "=",
      even: "=",
      page: "="
    }
  };
}]);

/**
 * Created by aklimenko on 21.12.15.
 */

//canvas-holder => ex-container => ex-container-cell => ex-text-bubble => ex-text-container => ex-lacing-radio

coreApp.directive('taskLacing', ['$compile', function ($compile) {

  var getTemplate = function getTemplate(variants, classes, result, even) {
    var exContainers = '';
    for (var i = 0; i < variants[0].length; i++) {
      var txt1 = variants[0][i].text || '';
      var txt2 = variants[1][i].text || '';

      var img1_src = variants[0][i].img || '';
      var img2_src = variants[1][i].img || '';
      var img1 = '',
          img2 = '';

      if (img1_src != '') img1 = '<div class="ex-lacing-separator"></div><div class="ex-lacing-img"><img src="' + img1_src + '"/></div>';
      if (img2_src != '') img2 = '<div class="ex-lacing-separator"></div><div class="ex-lacing-img"><img src="' + img2_src + '"/></div>';
      if (txt1 != '') txt1 = '<div class="ex-text-container">' + txt1 + '</div>';
      if (txt2 != '') txt2 = '<div class="ex-text-container">' + txt2 + '</div>';

      exContainers += ['<div class="ex-container">', '<div class="ex-container-cell">', '<div class="variant" data-type="left" data-id="' + i + '">', img1, txt1, '<div class="ex-lacing-radio"></div>', '</div>', '</div>', '<div class="ex-container-cell">', '<div class="variant" data-type="right" data-id="' + i + '">', '<div class="ex-lacing-radio"></div>', txt2, img2, '</div>', '</div>', '</div>'].join('');
    }

    return ['<div class="' + classes + '">', '<div class="canvas-holder">' + exContainers, '<canvas class="canvasBlock" style="position: absolute; z-index: 1"></canvas>', '</div>', '<button class="task__btn btn--answer">Принять ответ</button>', '<button class="task__btn btn--repeat">Повторить</button>', '</div>'].join('');
  };

  var is_touch_device = function is_touch_device() {
    return !!('ontouchstart' in window);
  };

  var linker = function linker($scope, $element, $attrs) {
    if ($attrs.componentid) {
      $scope.componentid = $scope.$eval($attrs.componentid);
    }

    //=================================================
    //var _data = $scope.page.components[$scope.componentid].data;
    var _data = $scope.data;
    var _answer = _data.answer;
    var _variants = _data.variants;
    var _line_color = _data.lineColor || '#000';
    var _even = $scope.even;
    _data.result = _data.result || 0;
    _data.attempts = _data.attempts || 0; //кол-во попыток - если не было задано изначально, то 0

    $element.html(getTemplate(_variants, _data.classes, _data.result, $scope.even));

    if (_data.css != undefined) $($element).css(_data.css);

    _data.resultWin = {
      title: 'Нет ответа',
      text: "No Job!"
    };

    function rebuild() {
      $compile($element.contents())($scope);
    }

    function toggleModal(param) {

      switch (param) {
        case 'show':
          $($element).find('.ex-modal').modal('show');
          break;
        case 'hide':
          $($element).find('.ex-modal').modal('hide');
          break;
        default:
          alert('no such param');
      }
    }

    var modal = '<ex-modal-win title="data.resultWin.title" text="data.resultWin.text"></ex-modal-win>';
    var e = $compile(modal)($scope);
    $($element).append(modal);

    //====================================================================================
    //Логика задания======================================================================
    //Шнуровка - соединить элементы в столбцах, каждый с каждым

    var _click = is_touch_device() ? 'touchstart' : 'click';
    var _click_end = is_touch_device() ? 'touchend' : 'click';

    var _btnAnswer = $($element).find('.btn--answer');
    var _btnRepeat = $($element).find('.btn--repeat');

    var _variants_all = $($element).find('.variant');
    var _variants0 = $($element).find('.variant[data-type="left"]');
    var _variants1 = $($element).find('.variant[data-type="right"]');
    var canvas = $($element).find('.canvasBlock')[0];
    var ctx = canvas.getContext('2d');
    var select = null;
    var _radios = _variants_all.find('.ex-lacing-radio');

    /**
     * инициализация
     */
    init();
    function init() {
      rebuild();
      // Shuffle all list items within a list:
      _variants0 = $($element).find('.variant[data-type="left"]');
      _variants1 = $($element).find('.variant[data-type="right"]');
      _variants0.shuffle();
      _variants1.shuffle();
      _variants0 = $($element).find('.variant[data-type="left"]');
      _variants1 = $($element).find('.variant[data-type="right"]');
      _variants_all = $($element).find('.variant');
      _radios = _variants_all.find('.ex-lacing-radio');

      _variants_all.removeClass('disabled');
      _variants_all.removeClass('answered');
      _variants_all.removeClass('selected');
      _variants_all.attr('data-ans', '');

      _radios.off(_click, onSelect);
      _radios.on(_click, onSelect);

      _btnAnswer.addClass('disabled');
      _btnRepeat.addClass('disabled');
      _btnAnswer.off(_click, check);
      _btnRepeat.off(_click, init);

      $($element).find('.ex-modal').modal('hide');
      toggleModal('hide');

      resize(canvas);
      $(window).resize(function () {
        resize(canvas);
      });
    }

    /**
     * Выбор варианта
     * @param e
     */
    function onSelect(e) {
      //console.log('select')
      var current = $(this).parent();

      $.each(_variants_all, function (key, value) {
        if ($(value).attr('data-type') != current.attr('data-type')) return;

        if ($(value).is(current)) $(this).toggleClass('selected');else $(this).removeClass('selected');
      });
      if ($($element).find('.selected').length < 2) {
        return;
      } else {
        //console.info('выбрано 2 элемента');

        var first_el = $($element).find('.selected').eq(0);
        var second_el = $($element).find('.selected').eq(1);

        first_el.attr('data-ans', second_el.attr('data-id'));
        second_el.attr('data-ans', first_el.attr('data-id'));

        first_el.addClass('answered');
        second_el.addClass('answered');
        first_el.removeClass('selected');
        second_el.removeClass('selected');
        first_el.off(_click, onSelect);
        second_el.off(_click, onSelect);

        //draw lines================================================
        //drawLines()
      }

      //check answer==============================================
      var answered = $($element).find('.answered');

      if (answered.length == _variants_all.length) {
        _btnAnswer.removeClass('disabled');
        _btnRepeat.removeClass('disabled');
        _btnAnswer.one(_click, check);
        _btnRepeat.one(_click, init);
      } else if (answered.length > 1) {
        _btnRepeat.removeClass('disabled');
        _btnRepeat.one(_click, init);
        _btnAnswer.addClass('disabled');
        _btnAnswer.off(_click, check);
      } else {
        _btnAnswer.addClass('disabled');
        _btnRepeat.addClass('disabled');
        _btnAnswer.off(_click, check);
        _btnRepeat.off(_click, init);
      }
      resize(canvas);
    }

    /**
     * Рисуем шнурки
     */
    function drawLines() {

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      _variants0.each(function () {
        var v0 = $(this);

        if (!v0.hasClass('answered')) return;

        _variants1.each(function () {
          var v1 = $(this);

          if (!v1.hasClass('answered')) return;

          if (v1.attr('data-ans') == v0.attr('data-id')) {

            ctx.beginPath();
            var sx, sy, ex, ey;
            var firstRadio = v0.find('.ex-lacing-radio');
            var secondRadio = v1.find('.ex-lacing-radio');

            sx = v0.position().left + firstRadio.position().left + firstRadio.outerWidth(true) / 2;
            sy = v0.position().top + v0.outerHeight(true) / 2;

            ex = v1.position().left + secondRadio.position().left + secondRadio.outerWidth(true) / 2;
            ey = v1.position().top + v1.outerHeight(true) / 2;

            var realToCSSPixels = window.devicePixelRatio || 1;
            sx *= realToCSSPixels;
            sy *= realToCSSPixels;
            ex *= realToCSSPixels;
            ey *= realToCSSPixels;

            ctx.moveTo(sx, sy);
            ctx.lineTo(ex, ey);
            ctx.lineWidth = 12;
            ctx.strokeStyle = '#fff';
            ctx.stroke();
            ctx.lineWidth = 10;
            ctx.strokeStyle = _line_color;
            ctx.lineCap = 'round';
            ctx.stroke();
          }
        });
      });
    }

    /**
     * Проверка результата
     * @returns {number}
     */
    function check(e) {
      e.stopImmediatePropagation();
      // console.log('check')
      _btnAnswer.addClass('disabled');
      _btnAnswer.off(_click, check);

      _variants_all.addClass('disabled');
      _variants_all.off(_click, onSelect);

      /**calculating result**/
      var res = 0;

      $.each(_variants0, function (key, value) {
        if ($(this).attr('data-ans') == $(this).attr('data-id')) res++;
      });

      res < 0 ? res = 0 : res = Math.round(100 * res / _variants0.length);

      _data.result = res;
      _data.attempts++;

      if (_data.result == 100) {
        _data.resultWin.title = 'ВЕРНО';
        _data.resultWin.text = _data.feedback.right;
      } else {
        _data.resultWin.title = 'НЕВЕРНО';
        _data.resultWin.text = _data.feedback.wrong;
      }
      $scope.$emit('change_result', { result: _data.result });

      rebuild();
      //TODO: Разобраться с рендерингом директив===========================
      //$($element).find('ex-modal-win').replaceWith($compile(modal)($scope));

      toggleModal('show');

      return res;
    }

    /**
     * Обновляем canvas
     * @param gl
     */
    function resize(gl) {
      var realToCSSPixels = window.devicePixelRatio || 1;

      // Lookup the size the browser is displaying the canvas.

      var displayWidth = Math.floor(gl.clientWidth * realToCSSPixels);
      var displayHeight = Math.floor(gl.clientHeight * realToCSSPixels);

      // Check if the canvas is not the same size.
      if (gl.width != displayWidth || gl.height != displayHeight) {

        // Make the canvas the same size
        gl.width = displayWidth;
        gl.height = displayHeight;
      }
      drawLines();
    }
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: true,
    scope: {
      data: "=",
      even: "="
    }
  };
}]);

/**
 * Created by aklimenko on 29.02.16.
 */
/**
 * Created by aklimenko on 21.12.15.
 */

//canvas-holder => ex-container => ex-container-cell => ex-text-bubble => ex-text-container => ex-lacing-radio

coreApp.directive('taskMatchDropdown', ['$compile', function ($compile) {

  var getTemplate = function getTemplate(variants, classes, result, even, max_items) {

    var $template = $('<div>');

    //Основной компонент задания---------------------------------------------------
    var $component = $('<div>');
    $component.addClass(classes);

    var ans_id = 0;

    //<div class="form-group">
    //  <label for="sel1">Select list:</label>
    //  <select class="form-control" id="sel1">
    //    <option>1</option>
    //    <option>2</option>
    //    <option>3</option>
    //    <option>4</option>
    //  </select>
    //</div>

    //Контейнер таблицы---------------------------------------------------------------
    var $list = $('<table>');
    $list.addClass('matching-table-container');
    $list.addClass('table table-bordered');

    var $table_head = $('<thead>');
    var $table_body = $('<tbody>');

    for (var i = 0; i < variants.length; i++) {
      var $header = $('<th>' + variants[i].header + '</th>');
      $header.addClass('text-center');
      $table_head.append($header);

      //Контейнер для полей опций - содержит заголовок, поле ввода--
      var $field_group = $('<td>');
      $field_group.addClass('form--field--group variant col-xs-6');

      //блок выбора
      var $select_group = $('<select>');
      $select_group.addClass('form--field--group__select');
      $select_group.append('<option value="" selected disabled>...</option>');

      for (var j = 0; j < variants[i].options.length; j++) {
        var $option = $('<option>');
        $option.text(variants[i].options[j].text);
        $select_group.append($option);
      }
      $field_group.append($select_group);
      $table_body.append($field_group);
    }

    var $table_btn_wrapper = $('<div>');
    $table_btn_wrapper.addClass('table-btn-wrapper row');

    var $btn_wrap = $('<div class="col-xs-6"></div>');

    //add btn
    var $add_row = $('<button></button>');
    $add_row.addClass('btn btn-default create-row-btn glyphicon glyphicon-plus');
    $btn_wrap.append($add_row);

    $table_btn_wrapper.append($btn_wrap);

    //remove btn
    var $remove_row = $('<button></button>');
    $remove_row.addClass('btn btn-default remove-row-btn glyphicon glyphicon-minus');
    $btn_wrap = $('<div class="col-xs-6"></div>');
    $btn_wrap.append($remove_row);

    $table_btn_wrapper.append($btn_wrap);

    $list.append($table_head);
    console.log('list:', $list);
    $list.append($table_body);

    //Кнопка сохранить--------------------------------------------------------------
    var $btn_answer = $('<button class="task__btn btn--answer">Сохранить</button>');

    //Кнопка очистить---------------------------------------------------------------
    var $btn_repeat = $('<button class="task__btn btn--repeat">Очистить</button>');

    //Заполняем компонент и возвращаем заготовку------------------------------------
    $component.append($list);
    // $table_btn_wrapper.append($add_row);
    // $table_btn_wrapper.append($remove_row);
    $component.append($table_btn_wrapper);

    $component.append($btn_answer);
    $component.append($btn_repeat);
    $template.append($component);

    return $template.html();
  };

  var is_touch_device = function is_touch_device() {
    return !!('ontouchstart' in window);
  };

  //ENTERING POINT============================================================
  var linker = function linker($scope, $element, $attrs) {
    if ($attrs.componentid) {
      $scope.componentid = $scope.$eval($attrs.componentid);
    }

    //=================================================
    //var _data = $scope.page.components[$scope.componentid].data;
    var _data = $scope.data;
    var _answer = _data.answer;
    var _variants = _data.variants;
    var _even = $scope.even;
    _data.result = _data.result || 0;
    _data.attempts = _data.attempts || 0; //кол-во попыток - если не было задано изначально, то 0

    $element.html(getTemplate(_variants, _data.classes, _data.result, $scope.even, _data.max_items));

    if (_data.css != undefined) $($element).css(_data.css);

    _data.resultWin = {
      title: 'Нет ответа',
      text: "No Job!"
    };

    function rebuild() {
      $compile($element.contents())($scope);
    }

    function toggleModal(param) {

      switch (param) {
        case 'show':
          $($element).find('.ex-modal').modal('show');
          break;
        case 'hide':
          $($element).find('.ex-modal').modal('hide');
          break;
        default:
          alert('no such param');
      }
    }

    var modal = '<ex-modal-win title="data.resultWin.title" text="data.resultWin.text"></ex-modal-win>';
    var e = $compile(modal)($scope);
    $($element).append(modal);

    //====================================================================================
    //Логика задания======================================================================
    //Шнуровка - соединить элементы в столбцах, каждый с каждым

    var _click = is_touch_device() ? 'touchstart' : 'click';
    var _click_end = is_touch_device() ? 'touchend' : 'click';

    var _btnAnswer = $($element).find('.btn--answer');
    var _btnRepeat = $($element).find('.btn--repeat');
    var _btnCreate = $($element).find('.create-row-btn');
    var _btnRemove = $($element).find('.remove-row-btn');
    var _tableCont = $($element).find('.matching-table-container');

    var _variants_all = $($element).find('.variant');

    var _cur_step = 0;

    //TODO: recreation-v---v--------------------------------------------

    if (_data.usr_ans) {

      _data.usr_ans.forEach(function (item, index, elem) {
        addRow(item);
      });
    }

    /**
     * инициализация
     */
    init();
    function init() {
      rebuild();
      _cur_step = 0;
      // Shuffle all list items within a list:
      _variants_all = $($element).find('.variant');

      _variants_all.removeClass('disabled');
      _variants_all.removeClass('answered');
      _variants_all.removeClass('selected');
      _variants_all.attr('data-ans', '');

      _btnAnswer.addClass('disabled');
      _btnRepeat.addClass('disabled');
      _btnAnswer.off(_click, check);
      _btnRepeat.off(_click, init);

      $($element).find('.ex-modal').modal('hide');
      toggleModal('hide');
      if (_cur_step == 0) {
        _btnCreate.on('click', btnCreateRowHandler);
        _btnRemove.off('click', btnRemoveRowHandler);
        _btnRemove.prop('disabled', true);
      }

      _tableCont.find('tbody tr').each(function (index, value) {
        if (index > 0) $(this).remove();
      });
      activateColByCurStep();
    }

    function activateColByCurStep() {
      _tableCont.find('tbody tr td select').prop('disabled', true);
      _tableCont.find('tbody tr').each(function (index) {
        $(this).find('.prepended').remove();
        var $prep = $('<span>');
        $prep.addClass('prepended');
        $prep.text(index * 1 + 1 + ". ");

        $(this).find('td').eq(0).prepend($prep);
        var $select = $(this).find('td').eq(_cur_step).find('select');
        $select.prop('disabled', false);
        $select.on('change', function () {

          update();

          _btnRepeat.removeClass('disabled');
          _btnRepeat.on(_click, init);
        });

        update();
      });
    }

    function update() {
      if (checkColValues()) {
        _btnAnswer.removeClass('disabled');
        _btnAnswer.on(_click, check);
      } else {
        _btnAnswer.addClass('disabled');
        _btnAnswer.off(_click, check);
      }
      if (_cur_step != 0) {
        _btnCreate.off('click', btnCreateRowHandler);
        _btnCreate.prop('disabled', true);
        _btnRemove.off('click', btnRemoveRowHandler);
        _btnRemove.prop('disabled', true);
        return;
      }

      if (checkColValues()) {
        _btnCreate.on('click', btnCreateRowHandler);
        _btnCreate.prop('disabled', false);
      } else {
        _btnCreate.off('click', btnCreateRowHandler);
        _btnCreate.prop('disabled', true);
      }

      if (_tableCont.find('tbody tr').length > 1) {
        _btnRemove.on('click', btnRemoveRowHandler);
        _btnRemove.prop('disabled', false);
      } else {
        _btnRemove.off('click', btnRemoveRowHandler);
        _btnRemove.prop('disabled', true);
      }
    }

    function checkColValues() {
      var isComplete = true;
      _tableCont.find('tbody tr').each(function () {
        var $select = $(this).find('td').eq(_cur_step).find('select');
        if (!$select.val()) isComplete = false;
      });
      return isComplete;
    }

    function btnCreateRowHandler(e) {
      e.stopImmediatePropagation();
      addRow();
      activateColByCurStep();
    }

    function btnRemoveRowHandler(e) {
      e.stopImmediatePropagation();
      removeRow();
    }

    function addRow(selected_items) {

      if (_tableCont.find('tbody tr').length >= _data.max_items) {
        return;
      }

      var $newRow = $('<tr>');
      var $table_body = _tableCont.last();

      for (var i = 0; i < _data.variants.length; i++) {

        //Контейнер для полей опций - содержит заголовок, поле ввода--
        var $field_group = $('<td>');
        $field_group.addClass('form--field--group variant col-xs-6');

        //блок выбора
        var $select_group = $('<select>');
        $select_group.addClass('form--field--group__select styled-select semi-square');
        $select_group.append('<option value="" selected disabled>...</option>');

        for (var j = 0; j < _data.variants[i].options.length; j++) {
          var $option = $('<option>');
          $option.text(_data.variants[i].options[j].text);
          $select_group.append($option);
        }

        if (selected_items) $select_group.eq(selected_items[i]).prop('selected', true);

        $field_group.append($select_group);
        $newRow.append($field_group);
      }

      _tableCont.find('tbody').append($newRow);
      update();
    }

    function removeRow() {

      if (_tableCont.find('tbody tr').length < 2) {
        return;
      }
      _tableCont.find('tr').last().remove();

      update();
    }

    function getUserAns() {
      var usr_ans = [];

      for (var i = 0; i < _data.variants.length; i++) {
        var col = [];
        _tableCont.find('tbody tr').each(function (index, elem) {
          var $select = $(this).find('td').eq(i).find('select');
          var val = $select.val();
          if (!val) val = 0;

          var var_index = 0;
          _data.variants[i].options.forEach(function (item, index, arr) {
            if (item.text == val) var_index = index;
          });

          col.push(var_index);
        });
        usr_ans.push(col);
      }
      console.log('usr_ans:', usr_ans);
      return usr_ans;
    }

    /**
     * Проверка результата
     * @returns {number}
     */
    function check(e) {
      e.stopImmediatePropagation();
      // console.log('check')
      _btnAnswer.addClass('disabled');
      _btnAnswer.off(_click, check);

      _tableCont.find('tbody tr td select').prop('disabled', true);

      _cur_step++;
      if (_cur_step < _data.variants.length) {
        activateColByCurStep();
        return;
      }

      /**calculating result**/
      var res = 100;

      _data.result = res;

      _data.usr_ans = getUserAns();

      _data.attempts++;

      if (_data.result == 100) {
        _data.resultWin.title = 'ВЕРНО';
        _data.resultWin.text = _data.feedback.right;
      } else {
        _data.resultWin.title = 'НЕВЕРНО';
        _data.resultWin.text = _data.feedback.wrong;
      }
      $scope.$emit('change_result', {
        result: _data.result
      });

      //rebuild();
      //TODO: Разобраться с рендерингом директив===========================
      $($element).find('ex-modal-win').replaceWith($compile(modal)($scope));

      toggleModal('show');

      return res;
    }
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: true,
    scope: {
      data: "=",
      even: "="
    }
  };
}]);

/**
 * Created by aklimenko on 23.12.15.
 */

coreApp.directive('taskRangeItems', ['$compile', function ($compile) {

  var getTemplate = function getTemplate(variants, classes, result, even) {

    var list = '';
    for (var i = 0; i < variants.length; i++) {
      var txt = variants[i].text || '';
      var img_src = variants[i].img || '';

      if (txt != '') txt = '<div class="var__txt">' + txt + '</div>';
      if (img_src != '') img_src = '<div class="var__img"><img src="' + img_src + '"/></div>';

      if (!even) list += '<li var-id="' + i + '" class="variant">' + '<div class="var__btn var__up"></div>' + '<div class="var__btn var__down"></div>' + txt + img_src + '</li>';else list += '<li var-id="' + i + '" class="variant">' + img_src + txt + '<div class="var__btn var__down"></div>' + '<div class="var__btn var__up"></div></li>';
    }

    return '<div class="' + classes + '">' + '<ul class="task__variants">' + list + '</ul>' + '<button class="task__btn btn--answer">Принять ответ</button>' + '<button class="task__btn btn--repeat">Повторить</button>' + '</div>';
  };

  var is_touch_device = function is_touch_device() {
    return !!('ontouchstart' in window);
  };

  var linker = function linker($scope, $element, $attrs) {
    if ($attrs.componentid) {
      $scope.componentid = $scope.$eval($attrs.componentid);
    }

    //=================================================
    //var _data = $scope.page.components[$scope.componentid].data;
    var _data = $scope.data;
    var _answer = _data.answer;
    var _variants = _data.variants;
    var _even = $scope.even;

    _data.result = _data.result || 0;
    _data.attempts = _data.attempts || 0; //кол-во попыток - если не было задано изначально, то 0


    $element.html(getTemplate(_variants, _data.classes, _data.result, $scope.even));

    if (_data.css != undefined) $($element).css(_data.css);

    _data.resultWin = {
      title: 'Нет ответа',
      text: "No Job!"
    };

    function rebuild() {
      $compile($element.contents())($scope);
    }

    function toggleModal(param) {

      switch (param) {
        case 'show':
          $($element).find('.ex-modal').modal('show');
          break;
        case 'hide':
          $($element).find('.ex-modal').modal('hide');
          break;
        default:
          alert('no such param');
      }
    }

    var modal = '<ex-modal-win title="data.resultWin.title" text="data.resultWin.text"></ex-modal-win>';
    var e = $compile(modal)($scope);
    $($element).append(modal);

    //====================================================================================
    //Логика задания======================================================================
    //Ранжирование - расставить варианты в правильном порядке


    var _click = is_touch_device() ? 'touchstart' : 'click';
    var _click_end = is_touch_device() ? 'touchend' : 'click';

    var _btnAnswer = $($element).find('.btn--answer');
    var _btnRepeat = $($element).find('.btn--repeat');
    _variants = $($element).find('.variant');
    _variants.shuffle();

    var _btns_up = _variants.find('.var__up');
    var _btns_down = _variants.find('.var__down');

    var animating = false;

    /**
     * инициализация
     */
    init(); //инициализация
    function init() {
      rebuild();
      // Shuffle all list items within a list:
      _variants = $($element).find('.variant');
      _variants = $($element).find('.variant');
      _btns_up = _variants.find('.var__up');
      _btns_down = _variants.find('.var__down');
      _variants.removeClass('disabled');
      //_variants.removeClass('selected');
      //_variants.off(_click, onSelect);
      //_variants.on(_click, onSelect);

      _btnAnswer.removeClass('disabled');
      _btnAnswer.on(_click, check);

      _btnRepeat.addClass('disabled');
      _btnRepeat.off(_click, init);

      _btns_up.on(_click, onMoveUp);
      _btns_down.on(_click, onMoveDown);

      $($element).find('.ex-modal').modal('hide');
      toggleModal('hide');
      animating = false;
    }

    function onMoveUp(e) {

      _variants = $($element).find('.variant');
      if (animating) {
        return;
      }

      var current = $(this).closest('.variant');
      var prevDiv = current.prev();

      current.css('z-index', 1);
      current.addClass('animating');
      distance = current.outerHeight();

      if (prevDiv.length) {
        animating = true;
        $.when(current.animate({
          top: -prevDiv.outerHeight()
        }, 600), prevDiv.animate({
          top: distance
        }, 600)).done(function () {
          prevDiv.css('top', '0px');
          current.css('top', '0px');
          current.css('z-index', '');
          current.insertBefore(prevDiv);
          current.removeClass('animating');
          animating = false;
        });
      } else {
        //move all top
        var all = _variants.not(current);

        distance = current.outerHeight();
        var top_d = 0;

        all.each(function () {
          top_d += $(this).outerHeight();
        });

        animating = true;
        $.when(all.animate({
          top: -distance
        }, 600), current.animate({
          top: top_d
        }, 600)).done(function () {
          all.css('top', '0px');
          current.css('top', '0px');
          current.css('z-index', '');
          current.removeClass('animating');
          current.insertAfter(_variants.not(current).last());
          animating = false;
        });
      }
    }

    function onMoveDown(e) {

      _variants = $($element).find('.variant');
      if (animating) {
        return;
      }

      var current = $(this).closest('.variant');
      var nextDiv = current.next();

      current.css('z-index', 1);
      current.addClass('animating');
      distance = current.outerHeight();

      if (nextDiv.length) {
        animating = true;
        $.when(nextDiv.animate({
          top: -distance
        }, 600), current.animate({
          top: nextDiv.outerHeight()
        }, 600)).done(function () {
          nextDiv.css('top', '0px');
          current.css('top', '0px');
          current.css('z-index', '');
          current.insertAfter(nextDiv);
          current.removeClass('animating');
          animating = false;
        });
      } else {
        //move all top
        var all = _variants.not(current);

        distance = current.outerHeight();
        var top_d = 0;

        all.each(function () {
          top_d += $(this).outerHeight();
        });

        animating = true;
        $.when(all.animate({
          top: distance
        }, 600), current.animate({
          top: -top_d
        }, 600)).done(function () {
          all.css('top', '0px');
          current.css('top', '0px');
          current.css('z-index', '');
          current.removeClass('animating');
          current.insertBefore(_variants.first());
          animating = false;
        });
      }
    }

    /**
     * Проверка результата
     * @returns {number}
     */
    function check(e) {
      e.stopImmediatePropagation();
      //console.log('check')
      _btnAnswer.addClass('disabled');
      _btnAnswer.off(_click, check);

      _btnRepeat.on(_click, init);
      _btnRepeat.removeClass('disabled');

      _variants = $($element).find('.variant');
      _variants.addClass('disabled');

      var res = 0;

      for (var i = 0; i < _variants.length; i++) {
        if (_variants.eq(i).attr('var-id') == i) {
          res += 100 / _variants.length;
        }
      }
      res < 0 ? res = 0 : res = Math.round(res);

      _data.result = res;
      _data.attempts++;

      if (_data.result == 100) {
        _data.resultWin.title = 'ВЕРНО';
        _data.resultWin.text = _data.feedback.right;
      } else {
        _data.resultWin.title = 'НЕВЕРНО';
        _data.resultWin.text = _data.feedback.wrong;
      }
      $scope.$emit('change_result', { result: _data.result });

      rebuild();
      //TODO: Разобраться с рендерингом директив===========================
      //$($element).find('ex-modal-win').replaceWith($compile(modal)($scope));

      toggleModal('show');

      return res;
    }
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: true,
    scope: {
      data: "=",
      even: "="
    }
  };
}]);

/**
 * @ngdoc controller
 * @name coreApp:CrsAppCCtrl
 *
 * @description
 *
 *
 * @requires $scope
 * */
angular.module('coreApp').controller('CrsAppCtrl', ['$scope', 'CrsStateService', function ($scope, CrsStateService) {
  var CTRL = this;

  CTRL.goToNextPage = CrsStateService.goToNextPage;
  CTRL.goToPreviousPage = CrsStateService.goToPreviousPage;

  $scope.$watchCollection(function () {
    return CrsStateService.get;
  }, function () {
    CTRL.currentPageId = CrsStateService.get.currentPageId;
    CTRL.currentPageObject = CrsStateService.get.currentPageObject;
    CTRL.currentPageNumber = CrsStateService.get.currentPageNumber;
  });
}]);

/**
 * @ngdoc directive
 * @name coreApp:crsAppDirective
 *
 * @description
 * Course application root
 *
 * @restrict A
 * */

angular.module('coreApp').directive('crsApp', function () {
  return {
    restrict: 'E',
    scope: {},
    link: function link(scope, elem, attr) {},
    controller: 'CrsAppCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'course_player/app/crsAppTmpl.html'
  };
});

/**
 * @ngdoc controller
 * @name coreApp:DeviceCtrl
 *
 * @description
 * Controls device interactions
 *
 * @requires $scope
 * */
angular.module('coreApp').controller('DeviceCtrl', ['$scope', function ($scope) {

  //$ionicPlatform.onHardwareBackButton(function(){
  //  console.log('back');
  //  $scope.showOptions();
  //});

  /** Cordova Events
   * Full-list here:
   * https://cordova.apache.org/docs/en/latest/cordova/events/events.html
   *
   * - pause
   * - resume
   * - menubutton
   * - searchbutton
   * - startcallbutton
   * - endcallbutton
   * - volumedownbutton
   * - volumeupbutton
   */

  //$ionicPlatform.on("resume", function(){
  //
  //});
  //
  //$ionicPlatform.on("menubutton", function(){
  //  $scope.showContents();
  //});

}]);
/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsAccordionItem
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsAccordionItem', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    //controller: 'CrsAccordionItemCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div class="crs-accordion-item"><ng-transclude></ng-transclude></div>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsCatalogItem
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsCatalogItem', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {
      flexGtXs: '@'
    },
    //controller: 'CrsCatalogItemCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    replace: true,
    template: '<div class="crs-catalog-item md-whiteframe-3dp" ng-transclude></div>'
  };
});

/**
 * Created by aklimenko on 20.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsTaskButtons
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsTaskButtons', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: true,
    //controller: 'CrsTaskButtonsCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div class="crs-task-buttons" layout layout-align-gt-sm="start center" layout-align="space-between center">' + '<div flex="100" layout="row" layout-align-gt-sm="start center" layout-align="space-around center">' + '<md-button class="restart-btn md-raised md-primary" ng-click="restart()" ng-disabled="!isSelected()">Начать заново</md-button>' + '<md-button class="accept-btn md-raised md-primary" ng-click="accept()" ng-disabled="!isSelected()||isEnded">Принять ответ</md-button>' + '</div>' + '</div>' + '</div>'
  };
});

/**
 * Created by aklimenko on 24.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsTaskMatching
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsTaskMatching', ['$compile', 'UtilityService', function ($compile, UtilityService) {
  return {
    restrict: 'E',
    prelink: function prelink() {},
    link: function link(scope, elem, attr, ctrl, templFn) {
      scope.variants = [];
      scope.options = [];
      console.log('withNums:', !!scope.withNums);

      templFn(scope, function (content) {
        angular.forEach(content, function (val, key) {
          var $val = $(val);
          if ($val.is('crs-task-variant')) {
            scope.variants.push({
              item: $val.contents(),
              question: $val.attr('data-question'),
              answer: $val.attr('data-answer'),
              showNums: scope.withNums
            });
          } else if ($val.is('crs-task-option')) {
            scope.options.push({
              item: $val.contents(),
              id: $val.attr('data-id'),
              text: $val.attr('data-text')
            });
          } else if ($val.is('crs-task-description')) {
            // console.log('1addition data:', $val.contents())
            elem.find('.crs-task__addition-content').append($val.contents());
          }
        });
      });

      $compile(elem.contents())(scope);

      //onRestart
      scope.restart = function () {
        mixVariants();
        scope.selected = undefined;
        //$radios.attr('disabled', false);
        scope.isEnded = false;
        angular.forEach(scope.variants, function (val, key) {
          val.disabled = false;
        });
      };

      //onAccept
      scope.accept = function () {
        var sum = 0;

        angular.forEach(scope.variants, function (val, key) {
          val.disabled = true;
          sum += 1 * (val.answer == val.selected);
        });
        scope.result = sum / scope.variants.length;
        scope.isEnded = true;
        scope.changeResult(scope.result);
      };

      scope.deactivateButton = function () {
        //scope.!isSelected();
        scope.isEnded = true;
        // console.log('Функция - deactivateButton',scope.rightAnswerShow);
      };

      scope.showRightAnswer = function () {
        console.log('Функция - showRightAnswer1', scope.rightAnswerShow);
        //scope.isEnded = true;
        //scope.isFailed = false;
        //scope.variants.disabled = true;


        if (scope.rightAnswerShow == "false") return;

        console.log('Функция - showRightAnswer2', scope.rightAnswerShow);
        //Show right answer
        angular.forEach(scope.variants, function (val, key) {
          val.selected = val.answer;
          val.disabled = true;
        });

        //scope.selected = scope.rightAnswer;
        //scope.contentVisible = true;
        //scope.contentInvisible = true;
        //scope.isVisibDiv1 = false;
        //scope.isVisibDiv2 = true;
      };

      //check if options selected for all variants
      scope.isSelected = function () {
        if (scope.isFailed) return false;
        var hasEmpty = false;
        angular.forEach(scope.variants, function (val, key) {
          if (!val.selected) hasEmpty = true;
        });

        return !hasEmpty;
      };

      function mixVariants() {
        scope.variants = UtilityService.randomizeArray(scope.variants);

        angular.forEach(scope.variants, function (val, key) {
          val.selected = null;
        });
      }

      scope.restart();
    },
    scope: {
      laces: '@',
      withNums: '@',
      rightAnswer: '@',
      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      correctAnswer: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      contentVisible: '@',
      contentInvisible: '@',
      hideDelayTime: '@'
    },
    controller: 'CrsTaskCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    templateUrl: function templateUrl(scope) {
      if (scope.laces) return 'components/tasks/task-matching/taskMatchingLacesTmpl.html';

      return 'components/tasks/task-matching/taskMatchingTmpl.html';
    }
  };
}]);

/**
 * Created by aklimenko on 24.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsTaskMatching
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsTaskMatchingLaces', ['$compile', 'UtilityService', function ($compile, UtilityService) {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr, ctrl, templFn) {
      scope.variants = [];
      scope.options = [];

      templFn(scope, function (content) {
        angular.forEach(content, function (val, key) {
          var $val = $(val);
          if ($val.is('crs-task-variant')) {
            scope.variants.push({
              item: $val.contents(),
              question: $val.attr('data-question'),
              answer: $val.attr('data-answer')
            });
          } else if ($val.is('crs-task-option')) {
            scope.options.push({
              item: $val.contents(),
              id: $val.attr('data-id'),
              text: $val.attr('data-text')
            });
          }
        });
      });

      $compile(elem.contents())(scope);

      //onRestart
      scope.restart = function () {
        mixVariants();
        scope.selected = undefined;
        //$radios.attr('disabled', false);
        scope.isEnded = false;
        angular.forEach(scope.variants, function (val, key) {
          val.disabled = false;
        });
      };

      //onAccept
      scope.accept = function () {
        var sum = 0;

        angular.forEach(scope.variants, function (val, key) {
          val.disabled = true;
          sum += 1 * (val.answer == val.selected);
        });
        scope.result = sum / scope.variants.length;
        scope.isEnded = true;
        scope.changeResult(scope.result);
      };
      //
      // check if options selected for all variants
      scope.isSelected = function () {
        var hasEmpty = false;
        angular.forEach(scope.variants, function (val, key) {
          if (!val.selected) hasEmpty = true;
        });

        return !hasEmpty;
      };

      function mixVariants() {
        scope.variants = UtilityService.randomizeArray(scope.variants);

        angular.forEach(scope.variants, function (val, key) {
          val.selected = null;
        });
      }

      scope.restart();
    },
    scope: {},
    controller: 'CrsTaskCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    templateUrl: 'components/tasks/task-matching-laces/taskMatchingLacesTmpl.html'
  };
}]);

/**
 * Created by aklimenko on 31.03.16.
 *
 * Creates laces for matching task by canvas
 *
 */

'use strict';

coreApp.directive('matchingLaces', ['$window', function ($window) {

  var linker = function linker($scope, $element, $attrs) {
    //console.log('matchingLaces init:',$scope.coords);
    $scope.coordinates = [];
    var canvas = $element.find('.canvasBlock')[0];
    var ctx = canvas.getContext('2d');

    var canvas_css = {
      position: 'absolute',
      'z-index': 1,
      width: '100%',
      height: '100%',
      top: 0,
      left: 0
    };

    $element.find('.canvasBlock').css(canvas_css);
    /**
     * Разумеется нужно слушать изменения размеров окна,
     * чтобы адекватно масштабировать канвас
     */
    angular.element($window).on('resize', function () {
      //console.log('resize');
      update();
      $scope.$apply();
    });

    /**
     * Нужно получать события от упражнения
     * сброс, обновление, блокировка и тд.
     */
    $scope.$on('update', function () {
      //console.log('update')
      update();
    });

    function update() {
      //console.log('matchingLaces update coords',$scope.coords);
      updateCoordinates();
      resize(canvas);
    }

    /**
     * Рисуем линии по координатам
     */
    function drawLines() {

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      $.each($scope.coordinates, function (key, pos) {

        ctx.beginPath();
        ctx.moveTo(pos.sx, pos.sy);
        ctx.lineTo(pos.ex, pos.ey);
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#' + (Math.random() * 0xAAAAAA << 0).toString(16);
        ctx.lineCap = 'round';
        ctx.stroke();
      });
    }

    /**
     * Обновляем canvas
     * @param gl
     */
    function resize(gl) {
      var realToCSSPixels = window.devicePixelRatio || 1;

      // Lookup the size the browser is displaying the canvas.

      var displayWidth = Math.floor(gl.clientWidth * realToCSSPixels);
      var displayHeight = Math.floor(gl.clientHeight * realToCSSPixels);

      // Check if the canvas is not the same size.
      if (gl.width != displayWidth || gl.height != displayHeight) {

        // Make the canvas the same size
        gl.width = displayWidth;
        gl.height = displayHeight;
      }
      drawLines();
    }

    /**
     * Обновляет координаты точек для шнуровки
     */
    function updateCoordinates() {
      $scope.coordinates = [];
      $.each($scope.variants, function (key, variant) {
        $.each(variant.match, function (n, answer) {

          var $vrnt = $element.find('.ex-variant[data-id="' + key + '"]').eq(0);
          var $answ = $element.find('.ex-answer[data-id="' + $scope.answers.indexOf(answer) + '"]').eq(0);

          var $cont1 = $element.find('.ex-container-variants');
          var $cont2 = $element.find('.ex-container-answers');

          var radio1 = $vrnt.find('.ex-lacing-radio-wrap');
          var radio2 = $answ.find('.ex-lacing-radio-wrap');

          //console.log(radio1, 'radio1 pos:', radio1.position());
          var sx, sy, ex, ey;
          sx = $cont1.position().left + $vrnt.position().left + radio1.position().left + radio1.outerWidth(true) / 2;
          sy = $vrnt.position().top + $vrnt.outerHeight(true) / 2;

          ex = $cont2.position().left + $answ.position().left + radio2.position().left + radio2.outerWidth(true) / 2;
          ey = $answ.position().top + $answ.outerHeight(true) / 2;

          var realToCSSPixels = window.devicePixelRatio || 1;
          sx *= realToCSSPixels;
          sy *= realToCSSPixels;
          ex *= realToCSSPixels;
          ey *= realToCSSPixels;

          $scope.coordinates.push({
            sx: sx,
            sy: sy,
            ex: ex,
            ey: ey
          });
        });
      });
    }
  };

  return {
    restrict: 'E',
    link: linker,
    replace: false,
    scope: true,
    template: '<div>\n      <div layout="row" layout-padding>\n        <div class="crs-task-matching--variants" layout="column" flex="50">\n          <div ng-repeat="variant in variants">\n            <div class="crs-task-matching--variant">\n              <span>{{variant.question}}</span>\n            </div>\n          </div>\n        </div>\n        <div class="crs-task-matching--options" layout="column" flex="50">\n          <div ng-repeat="option in options">\n            <div class="crs-task-matching--option">\n              <span>{{option.text}}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n      <canvas class="canvasBlock" style="position: absolute; z-index: 1"></canvas>\n    </div>'
  };
}]);

/**
 * Created by aklimenko on 20.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsTaskMultiChoice
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsTaskMultiChoice', ['$compile', 'UtilityService', '$mdToast', function ($compile, UtilityService, $mdToast) {
  return {
    restrict: 'E',
    link: function link(scope, elem) {
      //initialization *************************************
      scope.rightAnswer = [];

      scope.isRight = scope.result == 1;
      //temporary container for transcluded nodes
      var $tmp = elem.find('.task-tmp');
      var $crsVariants = $tmp.find('crs-task-variant');

      //radio button group
      var $group = elem.find('.task-group');

      //create and compile radio buttons
      angular.forEach($crsVariants, function (val, i) {
        // console.log('Функция - создание радио баттонов');
        var $variantWrapper = angular.element('<div>');

        angular.forEach($crsVariants.eq(i)[0].attributes, function (attr, key) {
          if (attr.name == 'data-value') return;
          $variantWrapper.attr(attr.name, attr.value);
        });

        $variantWrapper.addClass('variant-wrapper');

        var $cb = angular.element('<md-checkbox>');
        $cb.attr('aria-label', i);
        $cb.attr('ng-model', 'selected[' + i + ']');

        $variantWrapper.append($cb);
        $group.append($variantWrapper);
      });

      $compile($group.contents())(scope);
      var $checkboxes = $group.find('md-checkbox');

      //append variants from tmp container to button labels
      angular.forEach($crsVariants, function (el, key) {
        var $cb = $group.find('md-checkbox .md-label').eq(key);
        var $variant = angular.element(el);
        scope.rightAnswer.push($variant.attr('data-value'));
        $cb.append($variant.contents());
      });

      //delete tmp container
      elem.find('.task-tmp crs-task-variant').remove();

      //end of initialization *******************************

      //onRestart
      scope.restart = function () {
        //mixing variants
        // console.log('Функция - restart',scope.rightAnswerShow);
        //console.log('restart - rightAnswerShow:  ',scope.rightAnswerShow);
        //console.log('restart - rightAnswerShow: ');
        var wrappers = elem.find('.variant-wrapper');
        var $rnd = UtilityService.randomizeArray(wrappers);
        angular.forEach($rnd, function (val) {
          return $group.append(val);
        });
        scope.selected = _.map($checkboxes, function (c) {
          return false;
        });
        $checkboxes.attr('disabled', false);
        scope.isEnded = false;
      };

      //onAccept
      scope.accept = function () {
        //console.log('Функция - accept');
        $checkboxes.attr('disabled', true);

        //------------------------------------------------------
        var res = 0; //result

        //кол-во правильных
        var n = _.chain(scope.rightAnswer).filter(function (val) {
          return val == 1;
        }).value().length;
        //кол-во неправильных
        var nw = scope.rightAnswer.length - n;

        /**calculating result**/
        if (n < nw) {
          var wn = 0; //right answers weight
          var wp = 0; //wrong answers weight

          angular.forEach(scope.selected, function (value, key) {
            if (!value) return;
            if (scope.rightAnswer[key] == 1) {
              wp += 1 / n;
            } else if (scope.rightAnswer[key] == 0) {
              wn += 1 / (scope.rightAnswer.length - n);
            }
          });

          res = wp - wn;
        } else {
          angular.forEach(scope.selected, function (value, key) {
            if (!value) return;
            if (scope.rightAnswer[key] == 1) {
              res += 1 / n;
            } else if (scope.rightAnswer[key] == 0) {
              res -= 1 / n;
            }
          });
        }

        res < 0 ? res = 0 : res = Math.round(res * 100) / 100;
        //-----------------------------------------------------

        scope.isRight = res == 1;
        scope.result = res;
        scope.isEnded = true;
        scope.changeResult(scope.result);
      };

      scope.showRightAnswer = function () {
        //if (!!scope.rightAnswerShow) return console.log('not show rightanswer')
        if (scope.rightAnswerShow == "false") return;
        //console.log('Функция - showRightAnswer');
        $checkboxes.attr('disabled', true);
        scope.isEnded = true;
        scope.selected = scope.rightAnswer
        //.filter(a=>a==1)
        .map(function (a) {
          return !!parseInt(a);
        });
        //console.log(scope.selected)
      };

      scope.deactivateButton = function () {
        //scope.!isSelected();
        //console.log('Функция - deactivateButton');
      };

      //check if there is a selected object
      scope.isSelected = function () {
        //console.log('Функция - isSelected');
        return scope.selected.indexOf(true) != -1 && !scope.isFailed;
      };

      //check if there is a selected object
      // scope.isSelected = () => scope.selected.indexOf(true) != -1

      scope.restart();
    },
    scope: {

      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      correctAnswer: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      hideDelayTime: '@'
    },
    controller: 'CrsTaskCtrl',
    transclude: true,
    template: '<div class="crs-task-multi-choice">' + '<crs-task-completed ng-if="isRight"></crs-task-completed>' + '<div class="task-tmp" ng-transclude></div>' + '<div class="task-group" ' + 'ng-model="selected"  ' + 'layout="column" ' + 'layout-wrap ' + 'layout-gt-xs="row" ' + 'layout-padding-sm></div>' + '<crs-task-buttons></crs-task-buttons>' +
    // ' <p>selected: {{selected}}</p>' +
    // ' <p>result: {{result}}</p>' +
    '</div>'
  };
}]);

/**
 * Created by ppodgorny on 01.11.2016.
 */

/**
 * @ngdoc directive
 * @name coreApp:crsTaskMultiChoiceCol
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsTaskMultiChoiceCol', ['$compile', 'UtilityService', '$mdToast', function ($compile, UtilityService, $mdToast) {
  return {
    restrict: 'E',
    link: function link(scope, elem) {
      //initialization *************************************
      scope.rightAnswer = [];

      scope.isRight = scope.result == 1;
      //temporary container for transcluded nodes
      var $tmp = elem.find('.task-tmp');
      var $crsVariants = $tmp.find('crs-task-variant');

      //radio button group
      var $group = elem.find('.task-group');

      //create and compile radio buttons
      angular.forEach($crsVariants, function (val, i) {
        // console.log('Функция - создание радио баттонов');
        var $variantWrapper = angular.element('<div>');

        angular.forEach($crsVariants.eq(i)[0].attributes, function (attr, key) {
          if (attr.name == 'data-value') return;
          $variantWrapper.attr(attr.name, attr.value);
        });

        $variantWrapper.addClass('variant-wrapper');

        var $cb = angular.element('<md-checkbox>');
        $cb.attr('aria-label', i);
        $cb.attr('ng-model', 'selected[' + i + ']');

        $variantWrapper.append($cb);
        $group.append($variantWrapper);
      });

      $compile($group.contents())(scope);
      var $checkboxes = $group.find('md-checkbox');

      //append variants from tmp container to button labels
      angular.forEach($crsVariants, function (el, key) {
        var $cb = $group.find('md-checkbox .md-label').eq(key);
        var $variant = angular.element(el);
        scope.rightAnswer.push($variant.attr('data-value'));
        $cb.append($variant.contents());
      });

      //delete tmp container
      elem.find('.task-tmp crs-task-variant').remove();

      //end of initialization *******************************

      //onRestart
      scope.restart = function () {
        //mixing variants
        // console.log('Функция - restart',scope.rightAnswerShow);
        //console.log('restart - rightAnswerShow:  ',scope.rightAnswerShow);
        //console.log('restart - rightAnswerShow: ');
        var wrappers = elem.find('.variant-wrapper');
        var $rnd = UtilityService.randomizeArray(wrappers);
        angular.forEach($rnd, function (val) {
          return $group.append(val);
        });
        scope.selected = _.map($checkboxes, function (c) {
          return false;
        });
        $checkboxes.attr('disabled', false);
        scope.isEnded = false;
      };

      //onAccept
      scope.accept = function () {
        //console.log('Функция - accept');
        $checkboxes.attr('disabled', true);

        //------------------------------------------------------
        var res = 0; //result

        //кол-во правильных
        var n = _.chain(scope.rightAnswer).filter(function (val) {
          return val == 1;
        }).value().length;
        //кол-во неправильных
        var nw = scope.rightAnswer.length - n;

        /**calculating result**/
        if (n < nw) {
          var wn = 0; //right answers weight
          var wp = 0; //wrong answers weight

          angular.forEach(scope.selected, function (value, key) {
            if (!value) return;
            if (scope.rightAnswer[key] == 1) {
              wp += 1 / n;
            } else if (scope.rightAnswer[key] == 0) {
              wn += 1 / (scope.rightAnswer.length - n);
            }
          });

          res = wp - wn;
        } else {
          angular.forEach(scope.selected, function (value, key) {
            if (!value) return;
            if (scope.rightAnswer[key] == 1) {
              res += 1 / n;
            } else if (scope.rightAnswer[key] == 0) {
              res -= 1 / n;
            }
          });
        }

        res < 0 ? res = 0 : res = Math.round(res * 100) / 100;
        //-----------------------------------------------------

        scope.isRight = res == 1;
        scope.result = res;
        scope.isEnded = true;
        scope.changeResult(scope.result);
      };

      scope.showRightAnswer = function () {
        //if (!!scope.rightAnswerShow) return console.log('not show rightanswer')
        if (scope.rightAnswerShow == "false") return;
        //console.log('Функция - showRightAnswer');
        $checkboxes.attr('disabled', true);
        scope.isEnded = true;
        scope.selected = scope.rightAnswer
        //.filter(a=>a==1)
        .map(function (a) {
          return !!parseInt(a);
        });
        //console.log(scope.selected)
      };

      scope.deactivateButton = function () {
        //scope.!isSelected();
        //console.log('Функция - deactivateButton');
      };

      //check if there is a selected object
      scope.isSelected = function () {
        //console.log('Функция - isSelected');
        return scope.selected.indexOf(true) != -1 && !scope.isFailed;
      };

      //check if there is a selected object
      // scope.isSelected = () => scope.selected.indexOf(true) != -1

      scope.restart();
    },
    scope: {

      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      correctAnswer: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      hideDelayTime: '@'
    },
    controller: 'CrsTaskCtrl',
    transclude: true,
    template: '<div class="crs-task-multi-choice">' + '<crs-task-completed ng-if="isRight"></crs-task-completed>' + '<div class="task-tmp" ng-transclude></div>' + '<div class="task-group" ' + 'ng-model="selected"  ' + 'layout="column" ' + 'layout-wrap ' + 'layout-padding-sm></div>' + '<crs-task-buttons></crs-task-buttons>' +
    // ' <p>selected: {{selected}}</p>' +
    // ' <p>result: {{result}}</p>' +
    '</div>'
  };
}]);

/**
 * Created by ppodgorny on 31.10.2016.
 */

/**
 * @ngdoc directive
 * @name coreApp:crsTaskMultiChoicePic
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsTaskMultiChoicePic', ['$compile', 'UtilityService', '$mdToast', function ($compile, UtilityService, $mdToast) {
  return {
    restrict: 'E',
    link: function link(scope, elem) {
      //initialization *************************************
      scope.rightAnswer = [];

      scope.isRight = scope.result == 1;
      //temporary container for transcluded nodes
      var $tmp = elem.find('.task-tmp');
      var $crsVariants = $tmp.find('crs-task-variant');

      //radio button group
      var $group = elem.find('.task-group');

      //create and compile radio buttons
      angular.forEach($crsVariants, function (val, i) {
        // console.log('Функция - создание радио баттонов');
        var $variantWrapper = angular.element('<div>');

        angular.forEach($crsVariants.eq(i)[0].attributes, function (attr, key) {
          if (attr.name == 'data-value') return;
          $variantWrapper.attr(attr.name, attr.value);
        });

        $variantWrapper.addClass('variant-wrapper');

        var $cb = angular.element('<md-checkbox>');
        $cb.attr('aria-label', i);
        $cb.attr('ng-model', 'selected[' + i + ']');

        $variantWrapper.append($cb);
        $group.append($variantWrapper);
      });

      $compile($group.contents())(scope);
      var $checkboxes = $group.find('md-checkbox');

      //append variants from tmp container to button labels
      angular.forEach($crsVariants, function (el, key) {
        var $cb = $group.find('md-checkbox .md-label').eq(key);
        var $variant = angular.element(el);
        scope.rightAnswer.push($variant.attr('data-value'));
        $cb.append($variant.contents());
      });

      //delete tmp container
      elem.find('.task-tmp crs-task-variant').remove();

      //end of initialization *******************************

      //onRestart
      scope.restart = function () {
        //mixing variants
        // console.log('Функция - restart',scope.rightAnswerShow);
        //console.log('restart - rightAnswerShow:  ',scope.rightAnswerShow);
        //console.log('restart - rightAnswerShow: ');
        var wrappers = elem.find('.variant-wrapper');
        var $rnd = UtilityService.randomizeArray(wrappers);
        angular.forEach($rnd, function (val) {
          return $group.append(val);
        });
        scope.selected = _.map($checkboxes, function (c) {
          return false;
        });
        $checkboxes.attr('disabled', false);
        scope.isEnded = false;
      };

      //onAccept
      scope.accept = function () {
        //console.log('Функция - accept');
        $checkboxes.attr('disabled', true);

        //------------------------------------------------------
        var res = 0; //result

        //кол-во правильных
        var n = _.chain(scope.rightAnswer).filter(function (val) {
          return val == 1;
        }).value().length;
        //кол-во неправильных
        var nw = scope.rightAnswer.length - n;

        /**calculating result**/
        if (n < nw) {
          var wn = 0; //right answers weight
          var wp = 0; //wrong answers weight

          angular.forEach(scope.selected, function (value, key) {
            if (!value) return;
            if (scope.rightAnswer[key] == 1) {
              wp += 1 / n;
            } else if (scope.rightAnswer[key] == 0) {
              wn += 1 / (scope.rightAnswer.length - n);
            }
          });

          res = wp - wn;
        } else {
          angular.forEach(scope.selected, function (value, key) {
            if (!value) return;
            if (scope.rightAnswer[key] == 1) {
              res += 1 / n;
            } else if (scope.rightAnswer[key] == 0) {
              res -= 1 / n;
            }
          });
        }

        res < 0 ? res = 0 : res = Math.round(res * 100) / 100;
        //-----------------------------------------------------

        scope.isRight = res == 1;
        scope.result = res;
        scope.isEnded = true;
        scope.changeResult(scope.result);
      };

      scope.showRightAnswer = function () {
        //if (!!scope.rightAnswerShow) return console.log('not show rightanswer')
        if (scope.rightAnswerShow == "false") return;
        //console.log('Функция - showRightAnswer');
        $checkboxes.attr('disabled', true);
        scope.isEnded = true;
        scope.selected = scope.rightAnswer
        //.filter(a=>a==1)
        .map(function (a) {
          return !!parseInt(a);
        });
        //console.log(scope.selected)
      };

      scope.deactivateButton = function () {
        //scope.!isSelected();
        //console.log('Функция - deactivateButton');
      };

      //check if there is a selected object
      scope.isSelected = function () {
        //console.log('Функция - isSelected');
        return scope.selected.indexOf(true) != -1 && !scope.isFailed;
      };

      //check if there is a selected object
      // scope.isSelected = () => scope.selected.indexOf(true) != -1

      scope.restart();
    },
    scope: {

      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      correctAnswer: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      hideDelayTime: '@'
    },
    controller: 'CrsTaskCtrl',
    transclude: true,
    template: '<div class="crs-task-multi-choice">' + '<crs-task-completed ng-if="isRight"></crs-task-completed>' + '<div class="task-tmp" ng-transclude></div>' + '<div class="task-group" ' + 'ng-model="selected"  ' + 'layout="column" ' + 'layout-wrap ' + 'layout-gt-xs="row" ' + 'layout-align-xs="center center" ' + 'layout-padding-sm></div>' + '<crs-task-buttons></crs-task-buttons>' +
    // ' <p>selected: {{selected}}</p>' +
    // ' <p>result: {{result}}</p>' +
    '</div>'
  };
}]);

angular.module('coreApp').directive('crsTaskForm', ['$compile', 'UtilityService', '$mdToast', function ($compile, UtilityService, $mdToast) {
  var _scope;

  return {
    restrict: 'E',
    link: function link(scope, elem) {
      //onRestart
      scope.restart = function () {
        scope.isEnded = true;
        elem.find('.task-input').attr('disabled', false).val('').keyup(function () {
          var allFieldsChange = true;
          elem.find('.task-input').each(function (i, v) {
            //console.info('each', $(v).val());
            if ($(v).val() == '') {
              allFieldsChange = false;
              return false;
            }
          });
          scope.isEnded = !allFieldsChange;
          $('.accept-btn').attr('disabled', !allFieldsChange);
        });
      };

      //onAccept
      scope.accept = function () {
        elem.find('.task-input').attr('disabled', true);
        var res = 0;
        elem.find('.task-input').each(function () {
          if ($(this).val() == $(this).attr('data-answer')) {
            res += 1 / elem.find('.task-input').length;
          }
        });
        res = res < 0 ? 0 : Math.round(res * 100) / 100;
        //-----------------------------------------------------
        scope.isRight = res == 1;
        scope.result = res;
        scope.isEnded = true;
        scope.changeResult(scope.result);
      };

      scope.deactivateButton = function () {
        //scope.!isSelected();
        scope.isEnded = false;
      };

      //check if there is a selected object
      scope.isSelected = function () {
        if (scope.isFailed) {
          return false;
        } else {
          return true;
        }
      };

      scope.restart();
    },
    scope: (_scope = {
      componentIndex: '@',
      laces: '@',
      withNums: '@',
      rightAnswer: '@',
      rightAnswerShow: '@'
    }, _defineProperty(_scope, 'componentIndex', '@'), _defineProperty(_scope, 'layoutGtSm', '@'), _defineProperty(_scope, 'attempts', '@'), _defineProperty(_scope, 'correctAnswer', '@'), _defineProperty(_scope, 'incorrectAnswer0', '@'), _defineProperty(_scope, 'incorrectAnswer1', '@'), _defineProperty(_scope, 'incorrectAnswer2', '@'), _defineProperty(_scope, 'contentVisible', '@'), _defineProperty(_scope, 'contentInvisible', '@'), _defineProperty(_scope, 'hideDelayTime', '@'), _scope),
    controller: 'CrsTaskCtrl',
    transclude: true,
    template: '<div class="crs-task-form">' + '<crs-task-completed ng-if="isRight"></crs-task-completed>' + '<div class="task-form" ng-transclude></div>' + '<crs-task-buttons></crs-task-buttons>' +
    // ' <p>selected: {{selected}}</p>' +
    // ' <p>result: {{result}}</p>' +
    '</div>'
  };
}]);

/**
 * Created by aklimenko on 21.12.15.
 */

angular.module('coreApp').directive('crsTaskLaces', ['UtilityService', function (UtilityService) {
  return {
    restrict: 'E',
    controller: 'CrsTaskCtrl',
    controllerAs: 'ctrl',
    scope: {
      laces: '@',
      withNums: '@',
      rightAnswer: '@',
      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      contentVisible: '@',
      contentInvisible: '@',
      hideDelayTime: '@'
    },
    transclude: true,
    templateUrl: 'components/tasks/task-laces/crsTaskLacesTmpl.html',
    link: function link(scope, elem, attr) {
      scope.isSelected = function () {
        if (scope.isFailed) {
          return false;
        } else {
          return true;
        }
      };

      var elem = elem[0];
      //scope.isEnded = true;
      /*
      var places = [
        "Склад сырья и исходных материалов.",
        "Склад готовых изделий изготовителя.",
        "Склад в месте потребления."
      ];
       var variants = [
        "Приемка, выгрузка, сортировка, хранение и подготовка продукции к производственному потреблению.",
        "Складирование, хранение, обработка продукции перед ее отправкой, маркировка, погрузка.",
        "Получение товаров, формирование торгового ассортимента, снабжение ими розничных торговых предприятий."
      ];
      */

      var placeList = elem.querySelectorAll(".category");
      var places = [];
      for (var i = 0; i < placeList.length; i++) {
        places[i] = placeList[i].textContent;
      }

      var variantList = elem.querySelectorAll(".variant");
      var variants = [];
      for (var i = 0; i < variantList.length; i++) {
        variants[i] = variantList[i].textContent;
      }
      elem.querySelector(".secret-info").remove();

      var ansList = [];
      var moveObj = [];
      var heightBlock = 0;
      var mainBlock = document.querySelector(".form__list");
      var number = [];

      /* Дублируем правильные варианты ответа */
      for (var i = 0; i < variants.length; i++) {
        ansList[i] = variants[i];
      }
      ;

      /* Перемешиваем варианты ответа */
      ansList = UtilityService.randomizeArray(ansList);

      /* Создаём элементы списка */
      for (var i = 0; i < ansList.length; i++) {
        var formLi = document.createElement('li');
        formLi.className = "form__item";
        elem.querySelector(".form__list").appendChild(formLi);

        var formLi2 = document.createElement('li');
        formLi2.className = "form__category-point";
        elem.querySelector(".form__category").appendChild(formLi2);
      }
      ;

      /* Заполняем элементы списка содержимым */

      var items = elem.querySelectorAll(".form__item");
      var category = elem.querySelectorAll(".form__category-point");
      for (var i = 0; i < ansList.length; i++) {
        category[i].innerHTML = '<p class="form__item-text">' + places[i] + '</p>';
        items[i].innerHTML = '<span class="fa fa-arrow-up form__arrow form__arrow--up"></span><p class="form__item-text">' + ansList[i] + '</p><span class="fa fa-arrow-down form__arrow form__arrow--down"></span>';
      }
      ;
      heightBlock = 48;

      /* Задаём размер блоку, абсолютно позиционируем и располагаем элементы в блоке */
      mainBlock.style.height = heightBlock * ansList.length + 'px';
      document.querySelector('.form__category').style.height = mainBlock.style.height;
      for (var i = 0; i < ansList.length; i++) {
        moveObj[i] = i * heightBlock;
        items[i].style.position = 'absolute';
        items[i].style.top = moveObj[i] + 'px';
        number[i] = i;
      }
      ;

      var arrowList = elem.querySelectorAll('.form__arrow');
      for (var i = 0; i < arrowList.length; i++) {
        arrowList[i].addEventListener('click', arrowClickHandler);
      }

      function arrowClickHandler(event) {
        var el = event.target;

        /* Получаем номер элемента списка, внутри которого произошёл клик на стрелку */
        function GetIdx() {
          var text = event.target.parentElement.querySelector(".form__item-text").textContent;
          var idx = ansList.indexOf(text);
          return idx;
        };

        /* блокировка стрелок элементов списка, находящихся в крайних положениях + учёт состояния кнопки "Ответить" */

        if (!scope.isEnded) {
          var k = GetIdx();
          var currentElemIdx = 0;
          var toggleElemIdx = 0;
          var toggleElem;

          if (angular.element(el).hasClass('form__arrow--down')) {
            if (k !== ansList.length - 1) {
              toggleElem = ansList[k + 1];

              ansList[k + 1] = ansList[k];
              ansList[k] = toggleElem;

              currentElemIdx = k;
              toggleElemIdx = k + 1;
            }
            ;
          } else if (angular.element(el).hasClass('form__arrow--up')) {
            if (k !== 0) {
              toggleElem = ansList[k - 1];
              ansList[k - 1] = ansList[k];
              ansList[k] = toggleElem;

              currentElemIdx = k;
              toggleElemIdx = k - 1;
            }
            ;
          }
          ;
          toggle(currentElemIdx, toggleElemIdx);
        }

        function toggle(currIdx, toggIdx) {
          if (currIdx > toggIdx) {
            var removed = ansList.slice(currIdx, 1);
            ansList.slice(toggIdx, 0, removed);
          } else {
            var removed = ansList.slice(toggIdx, 1);
            ansList.slice(currIdx, 0, removed);
          }
          ;
          var d = number[toggIdx];
          number[toggIdx] = number[currIdx];
          number[currIdx] = d;

          items[number[toggIdx]].style.top = moveObj[toggIdx] + 'px';
          items[number[toggIdx]].style.transition = '1s';
          items[number[toggIdx]].style.zIndex = 5;
          items[number[currIdx]].style.top = moveObj[currIdx] + 'px';
          items[number[currIdx]].style.transition = '1s';
          items[number[currIdx]].style.zIndex = 4;
        };
      }

      scope.accept = function () {
        scope.isEnded = true;

        /* Сравниваем элементы массивов */
        function isCompared(arr1, arr2) {
          return arr1.filter(function (item, index) {
            return item === arr2[index];
          }).length == arr1.length;
        };

        if (isCompared(ansList, variants)) {
          scope.changeResult(1);
        } else {
          scope.changeResult(0);
        }
        ;
      };

      scope.deactivateButton = function () {
        scope.isEnded = true;
        if (scope.rightAnswerShow == 'true') {
          for (var i = 0; i < ansList.length; i++) {
            items[i].style.top = moveObj[i] + 'px';
          };
          for (var i = 0; i < ansList.length; i++) {
            items[i].querySelector('.form__item-text').innerHTML = variants[i];
          };
          console.info('Показываем правильный ответ', scope.rightAnswerShow);
        } else {
          console.info('Не Показываем правильный ответ', scope.rightAnswerShow);
        }
        scope.isSelected();
      };

      scope.restart = function () {
        scope.isEnded = false;
        ansList = UtilityService.randomizeArray(ansList);

        for (var i = 0; i < ansList.length; i++) {
          items[i].querySelector('.form__item-text').innerHTML = ansList[i];
          number[i] = i;
          items[i].style.top = moveObj[i] + 'px';
        }
        ;
      };
    }
  };
}]);
angular.module("coreApp").controller('CrsTaskLacesCtrl', ['$scope', function ($scope) {}]);
angular.module('coreApp').directive('crsTaskMultiplyChoiceDisappeared', ['UtilityService', function (UtilityService) {
  return {
    restrict: 'E',
    controller: 'CrsTaskCtrl',
    controllerAs: 'ctrl',
    scope: {
      laces: '@',
      withNums: '@',
      rightAnswer: '@',
      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      correctAnswer: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      contentVisible: '@',
      contentInvisible: '@',
      hideDelayTime: '@'
    },
    transclude: true,
    templateUrl: 'components/tasks/task-multiply-choice-disappeared/crsTaskMultiplyChoiceDisappearedTmpl.html',
    link: function link(scope, elem, attr) {
      scope.isSelected = function () {
        if (scope.isFailed) {
          return false;
        } else {
          return true;
        }
      };

      var elem = elem[0];
      //scope.isEnded = true;
      /*
      var places = [
        "Склад сырья и исходных материалов.",
        "Склад готовых изделий изготовителя.",
        "Склад в месте потребления."
      ];
       var variants = [
        "Приемка, выгрузка, сортировка, хранение и подготовка продукции к производственному потреблению.",
        "Складирование, хранение, обработка продукции перед ее отправкой, маркировка, погрузка.",
        "Получение товаров, формирование торгового ассортимента, снабжение ими розничных торговых предприятий."
      ];
      */

      var placeList = elem.querySelectorAll(".category");
      var places = [];
      for (var i = 0; i < placeList.length; i++) {
        places[i] = placeList[i].textContent;
      }

      var variantList = elem.querySelectorAll(".variant");
      var variants = [];
      for (var i = 0; i < variantList.length; i++) {
        variants[i] = variantList[i].textContent;
      }
      elem.querySelector(".secret-info").remove();

      var copyList = [];
      /* Дублируем правильные варианты ответа */
      for (var i = 0; i < variants.length; i++) {
        copyList[i] = variants[i];
      }
      ;

      /* Перемешиваем варианты ответа */
      copyList = UtilityService.randomizeArray(copyList);

      // var rightNum = [];
      // for (var i = 0; i < variants.length; i++) {
      //   for (var n = 0; n < variants.length; n++) {
      //     if (variants[i] === copyList[n]) {
      //       rightNum[i] = i === 0 ? n : n + variants.length * i;
      //     }
      //   }
      // }

      // console.log(rightNum);

      /* Создаём списки */
      for (var i = 0; i < places.length; i++) {
        var text = document.createElement('p');
        text.className = "variant";
        elem.querySelector(".block").appendChild(text);
        text.innerHTML = places[i];
        var formUl = document.createElement('ul');
        formUl.className = "list";
        elem.querySelector(".block").appendChild(formUl);

        /* Создаём элементы списка */
        for (var j = 0; j < copyList.length; j++) {
          var formLi = document.createElement('li');
          formLi.className = "item";
          formUl.appendChild(formLi);
          formLi.innerHTML = copyList[j];
        }
        ;
      }
      var clickAnswer = 0;
      var ansList = [];
      var itemList = document.querySelectorAll(".item");
      var listList = document.querySelectorAll(".list");

      for (var i = 0; i < itemList.length; i++) {
        itemList[i].addEventListener("click", clickAction);
      };

      function clickAction(event) {

        var el = event.target;
        if (el.className === "item active") return;
        ++clickAnswer;
        for (var i = 0; i < listList.length; i++) {
          if (el.parentNode === listList[i]) {
            var n = i;
            console.info("var n = i; =", n, listList.length);
            if (clickAnswer == listList.length) {
              scope.isEnded = false;
              $('.accept-btn').attr('disabled', false);
              console.info("clickAnswer = ", clickAnswer);
              console.info("scope.isEnded = ", scope.isEnded);
            }
            break;
          };
        }
        var itemList = listList[n].querySelectorAll(".item");
        for (var i = 0; i < itemList.length; i++) {
          if (itemList[i] === el) {
            itemList[i].classList.add("active");
            ansList[n] = itemList[i].textContent;
          } else {
            itemList[i].classList.add("disappeared");
          };
        }
      };

      /* Дисейблим кнопку принять ответ до тех пор пока все ответы не будут выбраны  */
      scope.isEnded = true;

      scope.accept = function () {
        console.info("scope.accept = function ", scope.isEnded);
        scope.isEnded = true;
        if (ansList.length !== variants.length) console.log("ERROR");
        /* Сравниваем элементы массивов */
        function isCompared(arr1, arr2) {
          return arr1.filter(function (item, index) {
            return item === arr2[index];
          }).length == arr1.length;
        };

        if (isCompared(ansList, variants)) {
          scope.changeResult(1);
        } else {
          scope.changeResult(0);
        }
        ;
        ansList = [];
      };

      scope.deactivateButton = function () {
        scope.isEnded = true;
        if (scope.rightAnswerShow == 'true') {
          var activeList = document.querySelectorAll(".item.active");
          for (var i = 0; i < activeList.length; i++) {
            activeList[i].innerHTML = variants[i];
          }
          console.info('Показываем правильный ответ', scope.rightAnswerShow);
        } else {
          console.info('Не Показываем правильный ответ', scope.rightAnswerShow);
        }
        scope.isSelected();
      };

      scope.restart = function () {
        scope.isEnded = true;
        clickAnswer = 0;
        ansList = [];
        for (var i = 0; i < itemList.length; i++) {
          if (itemList[i].classList.contains("disappeared")) {
            itemList[i].classList.remove("disappeared");
            itemList[i].style.visibility = 'hidden';
          } else {
            itemList[i].className = "item";
          };
        }
        setTimeout(function () {
          for (var i = 0; i < itemList.length; i++) {
            itemList[i].style = '';
          };
        }, 700);
      };
    }
  };
}]).directive('crsTaskMultiplyChoiceDisappearedDesktop', ['UtilityService', function (UtilityService) {
  return {
    restrict: 'E',
    controller: 'CrsTaskCtrl',
    controllerAs: 'ctrl',
    scope: {
      laces: '@',
      withNums: '@',
      rightAnswer: '@',
      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      correctAnswer: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      contentVisible: '@',
      contentInvisible: '@',
      hideDelayTime: '@'
    },
    transclude: true,
    templateUrl: 'components/tasks/task-multiply-choice-disappeared/crsTaskMultiplyChoiceDisappearedDesktopTmpl.html',
    link: function link(scope, elem, attr) {
      scope.isSelected = function () {
        if (scope.isFailed) {
          return false;
        } else {
          return true;
        }
      };

      var elem = elem[0];
      //scope.isEnded = true;
      /*
      var places = [
        "Склад сырья и исходных материалов.",
        "Склад готовых изделий изготовителя.",
        "Склад в месте потребления."
      ];
       var variants = [
        "Приемка, выгрузка, сортировка, хранение и подготовка продукции к производственному потреблению.",
        "Складирование, хранение, обработка продукции перед ее отправкой, маркировка, погрузка.",
        "Получение товаров, формирование торгового ассортимента, снабжение ими розничных торговых предприятий."
      ];
      */

      var placeList = elem.querySelectorAll(".category");
      var items1List = [];
      for (var i = 0; i < placeList.length; i++) {
        items1List[i] = placeList[i].textContent;
      }

      var variantList = elem.querySelectorAll(".variant");
      var items2List = [];
      for (var i = 0; i < variantList.length; i++) {
        items2List[i] = variantList[i].textContent;
      }
      elem.querySelector(".secret-info").remove();

      var ansList = []; // Array for shuffling variants of answer and array for comparison of user's and right answers
      var k = false; // Variable that shows activation of "clickEr"
      var lastNumber; // Show number of last active element in list
      var coord = []; // Array with static data, coordinates of elements points on the page 

      /* Copy variants for answer */

      for (var i = 0; i < items2List.length; i++) {
        ansList[i] = items2List[i];
      };

      /* Shuffle ansList[elem] */

      ansList = UtilityService.randomizeArray(ansList);

      /* Create elements of lists, add static data */

      for (var i = 0; i < items1List.length; i++) {
        var elem = document.createElement('li');
        elem.className = "task-item task-item--1";
        elem.innerHTML = '<p class="task-text">' + items1List[i] + '</p>' + '<div class="task-item-point"></div>';
        document.querySelector(".task-list--1").appendChild(elem);

        coord[i] = {
          content: items1List[i], // Text content of element
          item: "items1", // List "name"
          top: "", // Coordinates of points centers
          left: "",
          number2: "" // Number of element in pair
        };
      };

      for (var i = 0; i < items2List.length; i++) {
        var elem = document.createElement('li');
        elem.className = "task-item task-item--2";
        elem.innerHTML = '<p class="task-text">' + ansList[i] + '</p>' + '<div class="task-item-point"></div>';
        document.querySelector(".task-list--2").appendChild(elem);

        coord[i + items2List.length] = {
          content: ansList[i],
          item: "items2",
          top: "",
          left: "",
          number2: ""
        };
      };

      var group = document.querySelectorAll(".task-item");

      var clearNumber = coord.length;
      lastNumber = clearNumber;
      coord[lastNumber] = {
        item: ''
      };

      console.log("Ko " + document.querySelector(".task-container").offsetHeight);

      /* Add listeners to elements */

      for (var i = 0; i < group.length; i++) {
        group[i].addEventListener("click", isChosen);
      }

      function isChosen(e) {
        var el = e.target;
        if (el.tagName === 'LI') {
          el = el.querySelector(".task-item-point");
        } else {
          el = el.parentNode.querySelector(".task-item-point");
        };

        var idx = getIdx(el.parentNode.textContent);

        /* Coordinaters of points centers defined only inside this function (strange problem) */

        if (coord[idx].top === "") {
          coord[idx].top = getOffsetRect(el).top;
          coord[idx].left = getOffsetRect(el).left;
        }

        /* Double choice the same element */

        if (idx === lastNumber && el.classList.contains("act")) {
          el.classList.toggle("act");
          lastNumber = clearNumber;
          k = false;
          return;
        };

        /* We can't choose element of the same column */

        if (coord[idx].item === coord[lastNumber].item) return;

        /* Actions on state changes */

        if (el.classList.contains("act") && k === true) {
          return;
        } else if (el.classList.contains("act") && k === false) {
          group[coord[idx].number2].querySelector(".task-item-point").classList.remove("act");
          group[idx].querySelector(".task-item-point").classList.remove("act");

          if (idx < coord[idx].number2) {
            removeSVG(idx);
          } else {
            removeSVG(coord[idx].number2);
          };
          coord[coord[idx].number2].number2 = '';
          coord[idx].number2 = '';
          k = false;
        } else if (!el.classList.contains("act") && k === true) {
          coord[lastNumber].number2 = idx;
          coord[idx].number2 = lastNumber;

          el.classList.add("act");
          if (idx < lastNumber) {
            drawEr(coord[idx].left, coord[idx].top, coord[lastNumber].left, coord[lastNumber].top);
          } else {
            drawEr(coord[lastNumber].left, coord[lastNumber].top, coord[idx].left, coord[idx].top);
          };
          lastNumber = clearNumber;
          k = false;
        } else {
          el.classList.add("act");
          k = true;
          lastNumber = idx;
        };
      }

      /* Find element index */

      function getIdx(text) {
        for (var i = 0; i < coord.length; i++) {
          if (text === coord[i].content) return i;
        }
      }

      /* Find coordinates of points centers */

      function getOffsetRect(elem) {
        var box = elem.getBoundingClientRect();
        var container = document.querySelector(".task-container").getBoundingClientRect();

        var body = document.body;
        var docElem = document.documentElement;

        var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
        var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

        var clientTop = docElem.clientTop || body.clientTop || 0;
        var clientLeft = docElem.clientLeft || body.clientLeft || 0;

        var top = box.top - container.top + scrollTop - clientTop + elem.offsetHeight / 2;
        var left = box.left - container.left + scrollLeft - clientLeft + elem.offsetWidth / 2;
        console.log(scrollTop + ' ' + scrollLeft + ' ' + clientTop + ' ' + clientLeft + ' ' + top + ' ' + left);
        return { top: Math.round(top), left: Math.round(left) };
      }

      /* Remove <line>s */

      function removeSVG(index) {
        var list = document.querySelectorAll('line');
        for (var i = 0; i < list.length; i++) {
          if (list[i].getAttribute('y1') === String(coord[index].top)) {
            list[i].parentNode.removeChild(list[i]);
            return;
          }
        }
      }

      /* Create <line>s */

      function drawEr(x1, y1, x2, y2) {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", 'line');
        svg.setAttributeNS(null, "x1", x1);
        svg.setAttributeNS(null, "y1", y1);
        svg.setAttributeNS(null, "x2", x2);
        svg.setAttributeNS(null, "y2", y2);
        svg.style.strokeWidth = "4";
        svg.style.stroke = "gray";

        document.querySelector(".task-container").querySelector("svg").appendChild(svg);
      }

      /* Add listeners on window size change */

      window.addEventListener('resize', windowSizeChange);

      function windowSizeChange() {
        for (var i = 0; i < group.length; i++) {
          coord[i].top = getOffsetRect(group[i].querySelector(".task-item-point")).top;
          coord[i].left = getOffsetRect(group[i].querySelector(".task-item-point")).left;
        }
        document.querySelector(".task-container").querySelector("svg").innerHTML = '';
        for (var i = 0; i < group.length / 2; i++) {
          if (coord[i].number2 !== "") drawEr(coord[i].left, coord[i].top, coord[coord[i].number2].left, coord[coord[i].number2].top);
        }
      }

      /* Дисейблим кнопку принять ответ до тех пор пока все ответы не будут выбраны  */
      // scope.isEnded = true;

      scope.accept = function () {
        // document.querySelector(".task-box").style.pointerEvents = 'none';
        // btnAns.disabled = true; 

        // for (var i = 0; i < items2List.length; i++) {
        //   if (coord[i].number2 === '' || coord[coord[i].number2].content !== items2List[i]) {
        //     return document.querySelector(".response--false").classList.add("visible");
        //   } 

        // }

        // return document.querySelector(".response--true").classList.add("visible");
        scope.isEnded = true;
        if (ansList.length !== variants.length) console.log("ERROR");
        /* Сравниваем элементы массивов */
        function isCompared(arr1, arr2) {
          return arr1.filter(function (item, index) {
            return item === arr2[index];
          }).length == arr1.length;
        };

        if (isCompared(ansList, variants)) {
          scope.changeResult(1);
        } else {
          scope.changeResult(0);
        }
        ;
        ansList = [];
      };

      scope.deactivateButton = function () {
        scope.isEnded = true;
        if (scope.rightAnswerShow == 'true') {
          var activeList = document.querySelectorAll(".item.active");
          for (var i = 0; i < activeList.length; i++) {
            activeList[i].innerHTML = variants[i];
          }
          console.info('Показываем правильный ответ', scope.rightAnswerShow);
        } else {
          console.info('Не Показываем правильный ответ', scope.rightAnswerShow);
        }
        scope.isSelected();
        // btnAns.disabled = true;
        // btnRest.disabled = false;
        // document.querySelector("svg").innerHTML = '';
        // var list = document.querySelectorAll(".task-item");
        // for (var i = 0; i < items1List.length; i++) {
        //   for (var j = 0; j < items2List.length; j++) { 
        //     var n = j + items1List.length;
        //     if (list[n].textContent === items2List[i]) {
        //       drawEr(coord[i].left,coord[i].top,coord[n].left,coord[n].top);
        //       if (!list[n].querySelector(".task-item-point").classList.contains("active")) 
        //         list[n].querySelector(".task-item-point").classList.add("active");
        //       if (!list[i].querySelector(".task-item-point").classList.contains("active")) 
        //         list[i].querySelector(".task-item-point").classList.add("active");
        //       break;
        //     }
        //   }
        // }
      };

      scope.restart = function () {
        // btnAns.disabled = true;
        // ansTrue.classList.remove("visible");
        // ansFalse.classList.remove("visible");
        // document.querySelector(".task-box").removeAttribute('style');

        // document.querySelector("svg").innerHTML = '';
        // for (var i = 0; i < group.length; i++) {
        //   coord[i].number2 = '';
        //   group[i].querySelector(".task-item-point").classList.remove("active");
        // }

        // ansList.shuffle();
        // for (var i = 0; i < ansList.length; i++) {
        //   coord[i + items1List.length].content = ansList[i];
        //   group[i + items1List.length].querySelector(".task-text").innerHTML = ansList[i];
        // }
        scope.isEnded = true;
        clickAnswer = 0;
        ansList = [];
        for (var i = 0; i < itemList.length; i++) {
          if (itemList[i].classList.contains("disappeared")) {
            itemList[i].classList.remove("disappeared");
            itemList[i].style.visibility = 'hidden';
          } else {
            itemList[i].className = "item";
          };
        }
        setTimeout(function () {
          for (var i = 0; i < itemList.length; i++) {
            itemList[i].style = '';
          };
        }, 700);
      };
    }
  };
}]);
angular.module("coreApp").controller('crsTaskMultiplyChoiceDisappearedCtrl', ['$scope', function ($scope) {}]);
/**
 * Created by aklimenko on 20.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsTaskSingleChoice
 *
 * @description
 *
 *
 * @restrict E
 * */

angular.module('coreApp').directive('crsTaskSingleChoice', ['$compile', 'UtilityService', '_', function ($compile, UtilityService, _) {
  return {
    restrict: 'E',
    link: function link(scope, elem) {
      //initialization *************************************

      scope.isRight = scope.result == 1;

      //temporary container for transcluded nodes
      var $tmp = elem.find('.task-tmp');
      var $crsVariants = $tmp.find('crs-task-variant');

      //radio button group
      var $group = elem.find('.task-group');

      //create and compile radio buttons
      angular.forEach($crsVariants, function (vrnt, i) {
        var $variantWrapper = angular.element('<div>');

        angular.forEach($crsVariants.eq(i)[0].attributes, function (attr, key) {
          if (attr.name == 'data-value') return;
          $variantWrapper.attr(attr.name, attr.value);
        });

        $variantWrapper.addClass('variant-wrapper');
        $variantWrapper.addClass('shrink-fix');

        var $rb = angular.element('<md-radio-button>');
        $rb.attr('aria-label', i);
        $rb.attr('value', i);
        $variantWrapper.append($rb);
        $group.append($variantWrapper);
      });

      $compile($group.contents())(scope);
      var $radios = $group.find('md-radio-button');

      //append variants from tmp container to button labels
      angular.forEach($crsVariants, function (el, key) {
        var $rb = $group.find('md-radio-button .md-label').eq(key);
        var $variant = angular.element(el);
        $rb.append($variant.contents());
      });

      //delete tmp container
      elem.find('.task-tmp crs-task-variant').remove();

      //end of initialization *******************************

      //onRestart
      scope.restart = function () {
        //scope.isEvenSSS(1);
        if (scope.isFailed) return console.log('failed =(');
        //mix variants
        var wrappers = elem.find('.variant-wrapper');
        var $rnd = UtilityService.randomizeArray(wrappers);
        angular.forEach($rnd, function (val) {
          return $group.append(val);
        });
        scope.selected = undefined;
        $radios.attr('disabled', false);
        scope.isEnded = false;
        scope.isFailed = false;
        scope.isVisibDiv1 = true;
        scope.isVisibDiv2 = false;
      };

      //var a = isEvenSSS();
      //console.log('return- isEvenSSS ----------',a);
      //onAccept
      scope.accept = function () {
        // console.log('Функция - accept',scope.rightAnswerShow);
        $radios.attr('disabled', true);
        scope.isRight = scope.rightAnswer == scope.selected;
        scope.result = 1 * scope.isRight;
        scope.isEnded = true;
        scope.changeResult(scope.result);
      };

      scope.showRightAnswer = function () {

        if (scope.rightAnswerShow == "false") return;

        $radios.attr('disabled', true);
        scope.isEnded = true;
        scope.selected = scope.rightAnswer;
        scope.contentVisible = true;
        scope.contentInvisible = true;
        scope.isVisibDiv1 = false;
        scope.isVisibDiv2 = true;
      };

      scope.deactivateButton = function () {
        //scope.!isSelected();
        // console.log('Функция - deactivateButton',scope.rightAnswerShow);
      };

      //check if there is a selected object
      scope.isSelected = function () {
        return scope.selected != undefined && !scope.isFailed;
      };

      scope.isEvenSSS = function () {
        var a = scope.contentVisible;
        //  console.log('Функция - isEvenSSS*************', a);
        return a;
      };

      //scope.isEvenSSS();
      scope.restart();
    },
    scope: {
      rightAnswer: '@',
      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      correctAnswer: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      contentVisible: '@',
      contentInvisible: '@',
      hideDelayTime: '@'
    },

    controller: 'CrsTaskCtrl',
    //controller: 'AppCtrl',
    //controllerAs: 'ctrl',

    transclude: true,
    template: '<div class="crs-task-single-choice">' + '<crs-task-completed ng-if="isRight"></crs-task-completed>' + '<div class="task-tmp" ng-transclude></div>' + '<md-radio-group class="task-group column-fix" style="flex-wrap:wrap"' + 'ng-model="selected" ' + 'layout="column" ' + 'layout-gt-sm="{{layoutGtSm}}" ' + 'layout-padding-sm></md-radio-group>' +
    //'<div class="task-tooltip" ng-if="isFailed" ><h4>Полная фигня</h4></div>'+

    //'<md-toolbar class="md-hue-2" ng-if="isFailed" ><div class="md-toolbar-tools"><h4><span>Внимание - правильный ответ</span></h4> <span flex></span> </div> </md-toolbar>'+

    '<crs-task-buttons></crs-task-buttons>'
    // ' <p>selected: {{selected}}</p>' +
    // ' <p>result: {{result}}</p>' +

  };
}]);

/**
 * Created by aklimenko on 23.03.2016.
 */

'use strict';

coreApp.controller('taskExternalController', ['$scope', '$element', '$sce', function ($scope, $element, $sce) {
  $scope.url = $sce.trustAsResourceUrl($scope.data.url);
}]);

coreApp.directive('taskExternal', ['$window', function ($window) {

  function linker($scope, $element) {

    var $frame = $element.find('iframe');

    $scope.task = null;

    $scope.result = $scope.data.result;

    $scope.resultWinTitle = 'Поражение!';
    $scope.resultWinText = 'Результат';

    $frame.css('width', '100%');

    $frame.bind('load', function (event) {
      $scope.onFrameLoaded();
    });

    $scope.onFrameLoaded = function () {
      //console.log('frame loaded')
      $scope.task = $element.find('iframe')[0].contentWindow.task;

      if (!$scope.task) return;

      setFrameSize();

      $($window).on('resize', function () {
        setFrameSize();
      });

      function setFrameSize() {
        $element.find('iframe').contents().find('body').width($element.width()).css('margin', '0').css('padding', '0');
      }

      $frame.iFrameResize();

      $scope.task.init();

      $scope.task.taskContainer.bind('task:result', $scope.resultHandler);
    };

    $scope.resultHandler = function (event, data) {
      $scope.$apply(function () {
        $scope.result = data.result;
        $scope.resultWinTitle = data.result == 100 ? 'Победа!' : 'Поражение!';
        $scope.resultWinText = 'Результат: ' + data.result;
      });

      $scope.data.result = data.result;
      $scope.showTaskResultWin();
      //$element.find('.ex-modal').modal('show');
      //console.log('controller hear: task:result', data)
    };

    $scope.initTask = function () {

      $scope.task.init();
    };
  }

  return {
    restrict: 'EA',
    replace: false,
    scope: true,
    link: linker,
    controller: 'taskExternalController',
    templateUrl: 'page_components/task/taskExternal/task-external.html'

  };
}]);

/**
 * Created by aklimenko on 28.03.16.
 *
 * Controller for taskRebus directive
 */

"use strict";

coreApp.controller('TaskInputCtrl', ['$scope', 'UtilityService', function ($scope, UtilityService) {

  $scope.items = $scope.data.images;
  $scope.rightAnswer = $scope.data.rightAnswer;
  $scope.minLength = $scope.data.rightAnswer.length;
  $scope.maxLength = $scope.data.rightAnswer.length;
  $scope.placeholder = $scope.data.placeholder;
  $scope.quizImage = $scope.data.quizImage;

  $scope.quizText = UtilityService.textToBlockArray($scope.data.quizText);
}]);
/**
 * Created by aklimenko on 28.03.16.
 *
 * An exercise based on 1 input form to answer
 * and several pictures to guess the answer.
 *
 * It's structure looks like:
 {
    component: 'task-input',
    data: {
      images:[
        {src:'img/petruchio.png'},
        {src:'img/petruchio.png'},
        {src:'img/petruchio.png'},
      ],
      quizImage:'img/petruchio.png',
      quizText:[
        'Ship of a misty desolation, raid the madness.',
        'Laugh quirky like a rainy scallywag.',
        'All cannibals mark fine, jolly pirates.',
        'Belay, cloudy girl. go to isla de sangria.'
      ],
      rightAnswer:'петручо',
      placeholder:'введите ответ',
      feedback:{
        right:'правильно',
        wrong:'неправильно'
      },
      template:'input-rebus', //templates: input-rebus | input-quiz
      classes: "",
      css: {}
    }
  },
 */

'use strict';

coreApp.directive('taskInput', [function () {

  var linker = function linker($scope, $element) {
    $scope.user_answer = '';

    $scope.isAnswered = false;

    $scope.submitHandler = function () {
      if ($scope.isAnswered) restart();else check();
    };

    function restart() {
      $scope.isAnswered = false;
      $scope.user_answer = '';
    }

    function check() {
      $scope.isAnswered = true;
      if ($scope.user_answer.toLowerCase() == $scope.rightAnswer.toLowerCase()) {
        $scope.data.result = 100;
      } else {
        $scope.data.result = 0;
      }

      $scope.showTaskResultWin();
    }
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: false,
    scope: true,
    controller: 'TaskInputCtrl',
    templateUrl: function templateUrl($element, $attrs) {
      console.log('templateUrl:', $attrs.templateUrl);
      return 'page_components/task/taskInput/' + $attrs.templateUrl + '.html';
    }
  };
}]);

/**
 * Created by aklimenko on 18.03.16.
 */
'use strict';

coreApp.controller('TaskModalWinCtrl', ['$scope', '$element', 'close', function ($scope, $element, close) {

  $scope.close = function (param) {
    $element.modal('hide');
    close(param, 500); // close, but give 500ms for bootstrap to animate
  };
}]);

/**
 * Created by aklimenko on 17.12.15.
 */

'use strict';

coreApp.controller('ExModalWinController', ['$scope', '$attrs', function ($scope, $attrs) {
  $scope.title = $scope.resultWinTitle;
  $scope.text = $scope.resultWinText;
}]);

coreApp.directive('exModalWin', ['$compile', function ($compile) {

  var getTemplate = function getTemplate(title, text) {
    //console.log('create modal')
    return '<div class="ex-modal-container">' + '<div class="modal fade ex-modal" data-backdrop="static" role="dialog">' + '<div class="modal-dialog">' + '<div class="modal-content">' + '<div class="modal-header">' + '<button type="button" class="header__close" data-dismiss="modal"></button>' + '<h2 class="modal-title">' + title + '</h2>' + '</div>' + '<div class="modal-body">' + '<div class="addition-content">' + text + '</div>' + '</div>' + '<div class="modal-footer">' + '<button type="button" class="footer__close" data-dismiss="modal">продолжить <div class="img"></div> </button>' + '</div>' + '</div>' + '</div>' + '</div>' + '</div>';
  };

  var linker = function linker($scope, $element, $attrs) {
    //$element.html(getTemplate($scope.title, $scope.text));
    //var e = $compile($element.contents())($scope);
    //$($element).append(e);


    /** Разобраться!
                $scope.$watch(
                  function($scope) {
                    // watch the 'compile' expression for changes
                    return $scope.$eval($attrs.compile);
                  },
                  function(value) {
                    console.info('scope changed!')
                    // when the 'compile' expression changes
                    // assign it into the current DOM
                    $element.html(value);
                     // compile the new DOM and link it to the current
                    // scope.
                    // NOTE: we only compile .childNodes so that
                    // we don't get into infinite loop compiling ourselves
                    $compile($element.contents())($scope);
                  }
                );
     **/

  };

  return {
    template: '<div class="ex-modal-container">' + '<div class="modal fade ex-modal" data-backdrop="static" role="dialog">' + '<div class="modal-dialog">' + '<div class="modal-content">' + '<div class="modal-header">' + '<button type="button" class="close" data-dismiss="modal">X</button>' + '<h2 class="modal-title">{{resultWinTitle}}</h2>' + '</div>' + '<div class="modal-body">' + '<div class="addition-content">{{resultWinText}}</div>' + '</div>' + '</div>' + '</div>' + '</div>' + '</div>',
    restrict: 'EA',
    replace: true,
    controller: 'ExModalWinController',
    link: linker,
    scope: true
  };
}]);

/**
 * Created by aklimenko on 30.03.16.
 *
 * Controller for taskMatching directive
 */

"use strict";

coreApp.controller('TaskMatchingCtrl', ['$scope', 'UtilityService', function ($scope, UtilityService) {

  $scope.variants = $scope.data.variants;
  $scope.answers = $scope.data.answers;
  $scope.rightAnswer = $scope.data.rightAnswer;

  $.each($scope.variants, function (key, value) {
    value.text = UtilityService.textToBlockArray(value.text);
    value.selected = false;
    value.match = [];
  });

  $.each($scope.answers, function (key, value) {
    value.text = UtilityService.textToBlockArray(value.text);
    value.selected = false;
    value.match = [];
  });

  $scope.itemBootstrapColumn = function () {
    if ($scope.variants.length > 2) {
      return 'col-sm-4';
    } else if ($scope.variants.length == 2) {
      return 'col-sm-6';
    }

    return 'col-sm-12';
  }();

  $scope.getCols = function (index) {
    var row = index + 1;

    if (row % 6 == 0) {
      return 6;
    } else if (row % 2 == 0) {
      return 2;
    } else if (row % 3 == 0) {
      return 3;
    }

    return 1;
  };

  $scope.hasText = function (item) {
    return item.text[0] != '';
  };

  $scope.isRight = function (variant, answer) {
    return variant.rightAnswers.indexOf($scope.answers.indexOf(answer) + 1) != -1;
  };
}]);
/**
 * Created by aklimenko on 31.03.16.
 *
 * Creates laces for matching task by canvas
 *
 */

'use strict';

coreApp.directive('matchingLaces0', ['$window', function ($window) {

  var linker = function linker($scope, $element, $attrs) {
    //console.log('matchingLaces init:',$scope.coords);
    $scope.coordinates = [];
    var canvas = $element.find('.canvasBlock')[0];
    var ctx = canvas.getContext('2d');

    /**
     * Разумеется нужно слушать изменения размеров окна,
     * чтобы адекватно масштабировать канвас
     */
    angular.element($window).on('resize', function () {
      //console.log('resize');
      update();
      $scope.$apply();
    });

    /**
     * Нужно получать события от упражнения
     * сброс, обновление, блокировка и тд.
     */
    $scope.$on('update', function () {
      //console.log('update')
      update();
    });

    function update() {
      //console.log('matchingLaces update coords',$scope.coords);
      updateCoordinates();
      resize(canvas);
    }

    /**
     * Рисуем линии по координатам
     */
    function drawLines() {

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      $.each($scope.coordinates, function (key, pos) {

        ctx.beginPath();
        ctx.moveTo(pos.sx, pos.sy);
        ctx.lineTo(pos.ex, pos.ey);
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#' + (Math.random() * 0xAAAAAA << 0).toString(16);
        ctx.lineCap = 'round';
        ctx.stroke();
      });
    }

    /**
     * Обновляем canvas
     * @param gl
     */
    function resize(gl) {
      var realToCSSPixels = window.devicePixelRatio || 1;

      // Lookup the size the browser is displaying the canvas.

      var displayWidth = Math.floor(gl.clientWidth * realToCSSPixels);
      var displayHeight = Math.floor(gl.clientHeight * realToCSSPixels);

      // Check if the canvas is not the same size.
      if (gl.width != displayWidth || gl.height != displayHeight) {

        // Make the canvas the same size
        gl.width = displayWidth;
        gl.height = displayHeight;
      }
      drawLines();
    }

    /**
     * Обновляет координаты точек для шнуровки
     */
    function updateCoordinates() {
      $scope.coordinates = [];
      $.each($scope.variants, function (key, variant) {
        $.each(variant.match, function (n, answer) {

          var $vrnt = $element.find('.ex-variant[data-id="' + key + '"]').eq(0);
          var $answ = $element.find('.ex-answer[data-id="' + $scope.answers.indexOf(answer) + '"]').eq(0);

          var $cont1 = $element.find('.ex-container-variants');
          var $cont2 = $element.find('.ex-container-answers');

          var radio1 = $vrnt.find('.ex-lacing-radio-wrap');
          var radio2 = $answ.find('.ex-lacing-radio-wrap');

          //console.log(radio1, 'radio1 pos:', radio1.position());
          var sx, sy, ex, ey;
          sx = $cont1.position().left + $vrnt.position().left + radio1.position().left + radio1.outerWidth(true) / 2;
          sy = $vrnt.position().top + $vrnt.outerHeight(true) / 2;

          ex = $cont2.position().left + $answ.position().left + radio2.position().left + radio2.outerWidth(true) / 2;
          ey = $answ.position().top + $answ.outerHeight(true) / 2;

          var realToCSSPixels = window.devicePixelRatio || 1;
          sx *= realToCSSPixels;
          sy *= realToCSSPixels;
          ex *= realToCSSPixels;
          ey *= realToCSSPixels;

          $scope.coordinates.push({
            sx: sx,
            sy: sy,
            ex: ex,
            ey: ey
          });
        });
      });
    }
  };

  return {
    restrict: 'E',
    link: linker,
    replace: false,
    transclude: true,
    scope: true,
    template: '<span ng-transclude></span>'
  };
}]);

/**
 * Created by aklimenko on 30.03.16.
 *
 * An exercise match group of variants to group of answers
 *
 * It's structure looks like:

 {
   component: 'task-matching',
   data: {
     variants:[
       {
         image:'img/petruchio.png',
         text:['1 The proud whale', 'Loudly trades the wench.'],
         rightAnswers:[1,2]
       },
       {
         image:'img/petruchio.png',
         text:'2 Skull of a warm power, lead the love!',
         rightAnswers:[2]
       },
       {
         image:'img/petruchio.png',
         text:'3 The tuna vandalizes with courage, hail the seychelles!',
         rightAnswers:[1,2,3]
       }
     ],
     answers:[
       {
         image:'img/petruchio.png',
         text:'1 You have to wrestle, and receive core by your traveling.'
       },
       {
         image:'img/petruchio.png',
         text:'2 The visitor has death, but not everyone desires it.'
       },
       {
         image:'img/petruchio.png',
         text:'3 The vogon is more crewmate now than girl. harmless and accelerative ancient.'
       }
     ],
     feedback:{
       right:['Отлично!', 'Задание выполнено правильно!', 'Ты получаешь приз!'],
       wrong:['К сожалению, допущена ошибка!', 'Выполни задание ещё раз.']
     },
     template:'match-check', //варианты с галкой match-check
     classes: "",
     css: {}
  },
  */

'use strict';

coreApp.directive('taskMatching', [function () {

  var linker = function linker($scope, $element) {

    $scope.user_answer = [];
    $scope.isAnswered = false;

    $scope.currentSelectedItem = null;
    mix();

    function mix() {
      angular.forEach($scope.variants, function (item) {
        item.random = Math.random();
      });
      angular.forEach($scope.answers, function (item) {
        item.random = Math.random();
      });

      $scope.$broadcast('update');
    }

    function clearMatches() {
      $.each($scope.variants, function (key, item) {
        item.match = [];
      });

      $.each($scope.answers, function (key, item) {
        item.match = [];
      });

      $scope.$broadcast('update');
    }

    $scope.submitHandler = function () {
      if ($scope.isAnswered) restart();else check();
    };

    $scope.selectItem = function (item) {
      if (!$scope.currentSelectedItem) $scope.currentSelectedItem = item;else $scope.match($scope.currentSelectedItem, item);

      $scope.$broadcast('update');
    };

    $scope.match = function (item1, item2) {

      if ($scope.isAnswered) return null;
      if (!item1 || !item1) return null;
      if ($scope.answers.indexOf(item1) != -1 && $scope.answers.indexOf(item2) != -1 || $scope.variants.indexOf(item1) != -1 && $scope.variants.indexOf(item2) != -1) {
        if (item2 == $scope.currentSelectedItem) $scope.currentSelectedItem = null;else {
          $scope.currentSelectedItem = item2;
          return null;
        }
      }
      $scope.currentSelectedItem = null;

      if (item1.match.indexOf(item2) == -1) {
        item1.match.push(item2);
      } else {
        item1.match = $.grep(item1.match, function (item) {
          return item !== item2;
        });
      }

      if (item2.match.indexOf(item1) == -1) {
        item2.match.push(item1);
      } else {
        item2.match = $.grep(item2.match, function (item) {
          return item !== item1;
        });
      }

      $scope.$broadcast('update');
    };

    $scope.getMatching = function (arr) {
      var match = [];
      $.each(arr, function (key, obj) {
        if (obj.match.length) {
          match.push(obj.match);
          var r = '';
          $.each(obj.match, function (mk, val) {
            r += mk + ',';
          });
          console.log(key, ' -> ', r);
        }
      });

      return match;
    };

    $scope.isReady = function () {
      var ready = true;
      $.each($scope.variants, function (key, variant) {
        if (ready) ready = variant.match.length;
      });

      return ready;
    };

    function restart() {
      clearMatches();
      mix();
      $scope.isAnswered = false;
      $scope.$broadcast('update');
    }

    function check() {
      $scope.isAnswered = true;

      var res = 0;

      $.each($scope.variants, function (key, variant) {
        $.each(variant.match, function (key, match) {
          if (variant.rightAnswers.indexOf($scope.answers.indexOf(match) + 1) != -1) {
            res += 100 / $scope.variants.length / variant.rightAnswers.length;
          } else {
            res -= 100 / $scope.variants.length / variant.rightAnswers.length;
          }
        });
      });

      res < 0 ? res = 0 : res = Math.round(res);
      //-----------------------------------------------------

      $scope.data.result = res;

      $scope.showTaskResultWin();
      $scope.$broadcast('update');
    }
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: false,
    scope: true,
    controller: 'TaskMatchingCtrl',
    templateUrl: function templateUrl($element, $attrs) {
      console.log('templateUrl:', $attrs.templateUrl);
      return 'page_components/task/taskMatching/' + $attrs.templateUrl + '.html';
    }
  };
}]);

/**
 * Created by aklimenko on 28.03.16.
 *
 * Controller for taskSimpleChoice directive
 */

"use strict";

coreApp.controller('TaskSimpleChoiceCtrl', ['$scope', 'UtilityService', function ($scope, UtilityService) {

  $scope.variants = $scope.data.variants;
  $scope.rightAnswer = $scope.data.rightAnswer;
  $scope.sharedImage = $scope.data.sharedImage;
  $scope.sharedVideo = $scope.data.sharedVideo;

  $.each($scope.variants, function (key, value) {
    value.selected = false;
  });

  if ($scope.variants.length > 2) {
    $scope.itemBootstrapColumn = 'col-sm-4';
  } else if ($scope.variants.length == 2) {
    $scope.itemBootstrapColumn = 'col-sm-6';
  } else {
    $scope.itemBootstrapColumn = 'col-sm-12';
  }

  $scope.getCols = function (index) {
    var row = index + 1;

    if (row % 6 == 0) {
      return 6;
    } else if (row % 2 == 0) {
      return 2;
    } else if (row % 3 == 0) {
      return 3;
    }

    return 1;
  };

  $scope.hasText = function (index) {
    return $scope.variants[index].text[0] != '';
  };

  $scope.isSingleChoice = function () {
    var n_right = 0;
    $.each($scope.data.rightAnswer, function (key, value) {
      if (value == 1) {
        n_right++;
      }
    });
    return n_right == 1;
  };
}]);
/**
 * Created by aklimenko on 28.03.16.
 *
 * An exercise to choose 1 or more answer from
 * multiple variants
 *
 * It's structure looks like:

 {
    component: 'task-simple-choice',
    data: {
      variants:[
        {
          image:'img/petruchio.png', //для нескольких картинок
          text:['The proud whale', 'Loudly trades the wench.']
        },
        {
          image:'img/petruchio.png', //для нескольких картинок
          text:'Skull of a warm power, lead the love!'
        },
        {
          image:'img/petruchio.png', //для нескольких картинок
          text:'The tuna vandalizes with courage, hail the seychelles!'
        }
      ],
      sharedImage:'img/petruchio.png', //для одной картинки
      rightAnswer:[1,0,0], // 1 - правильный | 0 - неправильный
      placeholder:'введите ответ',
      feedback:{
        right:'правильно',
        wrong:'неправильно'
      },
      template:'choice-img', //несколько картинок choice-img | одна картинка: choice-var
      classes: "",
      css: {}
    }
  },
 */

'use strict';

coreApp.directive('taskSimpleChoice', [function () {

  var linker = function linker($scope) {

    $scope.user_answer = [];
    $scope.isAnswered = false;

    mix();

    function mix() {
      angular.forEach($scope.variants, function (item) {
        item.random = Math.random();
      });

      $scope.$broadcast('update');
    }

    $scope.submitHandler = function () {
      if ($scope.isAnswered) restart();else check();
    };

    $scope.selectItem = function (index) {
      if ($scope.isAnswered) return;

      //if one right answer then deselect others
      if ($scope.isSingleChoice()) {
        $.each($scope.variants, function (key, item) {
          item.selected = key == index;
        });
      } else {
        $scope.variants[index].selected = !$scope.variants[index].selected;
      }

      $scope.user_answer = [];
      $.each($scope.variants, function (key, item) {
        if (item.selected) $scope.user_answer.push(key);
      });
    };

    $scope.getSelected = function () {
      var selected = [];
      $.each($scope.variants, function (key, item) {
        if (item.selected) selected.push(key);
      });
      return selected;
    };

    function restart() {
      $.each($scope.variants, function (key, item) {
        item.selected = false;
      });
      $scope.isAnswered = false;
      $scope.user_answer = '';
      mix();
      $scope.$emit('page_reset');
    }

    function check() {
      $scope.isAnswered = true;

      //------------------------------------------------------
      var n = 0; //кол-во правильных
      var nw = 0; //кол-во неправильных
      var wn = 0;
      var wp = 0;
      var res = 0;

      $.each($scope.rightAnswer, function (key, value) {
        value == 1 ? n++ : nw++;
      });

      /**calculating result**/

      if (n < nw) {
        $.each($scope.getSelected(), function (key, value) {
          if ($scope.rightAnswer[value] == 1) {
            wp += 100 / n;
          } else if ($scope.rightAnswer[value] == 0) {
            wn += 100 / ($scope.rightAnswer.length - n);
          }
        });

        res = wp - wn;
      } else {
        $.each($scope.getSelected(), function (key, value) {

          if ($scope.rightAnswer[value] == 1) {
            res += 100 / n;
          } else if ($scope.rightAnswer[value] == 0) {
            res -= 100 / n;
          }
        });
      }

      res < 0 ? res = 0 : res = Math.round(res);
      //-----------------------------------------------------

      $scope.data.result = res;

      var add_msg = '';
      if (res < 100) add_msg = $scope.variants[$scope.user_answer[0]].feedback;
      $scope.showTaskResultWin(add_msg);

      //if (res<100) $scope.$emit('page_feedback', $scope.variants[$scope.user_answer[0]].feedback);
    }
  };

  return {
    restrict: 'EA',
    link: linker,
    replace: false,
    scope: true,
    controller: 'TaskSimpleChoiceCtrl',
    templateUrl: function templateUrl($element, $attrs) {
      console.log('templateUrl:', $attrs.templateUrl);
      return 'page_components/task/taskSimpleChoice/' + $attrs.templateUrl + '.html';
    }
  };
}]);

/**
 * @ngdoc controller
 * @name coreApp:CrsAppFooterCtrl
 *
 * @description
 *
 *
 * @requires $scope
 * */
"use strict";

angular.module('coreApp').controller('CrsAppFooterCtrl', ['$scope', 'CrsStateService', function ($scope, CrsStateService) {
  var CTRL = this;

  CTRL.goToNextPage = CrsStateService.goToNextPage;
  CTRL.goToPreviousPage = CrsStateService.goToPreviousPage;
  CTRL.isOnFirstPage = function () {
    return CrsStateService.get.isOnFirstPage;
  };
  CTRL.isOnLastPage = function () {
    return CrsStateService.get.isOnLastPage;
  };

  $scope.$watchCollection(function () {
    return CrsStateService.get;
  }, function () {
    CTRL.pageCounterText = CrsStateService.get.pageCounterText;
    CTRL.currentPageNumber = CrsStateService.get.currentPageNumber;
    CTRL.totalPages = CrsStateService.get.totalPages;
  });
}]);

/**
 * @ngdoc directive
 * @name coreApp:app-footerDirective
 *
 * @description
 *
 *
 * @restrict A
 * */
angular.module('coreApp').directive('crsAppFooter', function () {
  return {
    restrict: 'E',
    scope: {},
    controller: 'CrsAppFooterCtrl',
    controllerAs: 'ctrl',
    link: function link(scope, elem, attr) {},
    templateUrl: 'course_player/app/app-footer/crsAppFooterTmpl.html'
  };
});

/**
 * @ngdoc controller
 * @name coreApp:CrsAppHeaderCtrl
 *
 * @description
 *
 *
 * @requires $scope
 * */
angular.module('coreApp').controller('CrsAppHeaderCtrl', ['$scope', 'CrsStateService', '$mdSidenav', '$mdMedia', 'CrsGlossary', 'CrsStatistics', function ($scope, CrsStateService, $mdSidenav, $mdMedia, CrsGlossary, CrsStatistics) {
  var CTRL = this;

  CTRL.showGlossary = function (evt) {
    return CrsGlossary.show(evt);
  };

  CTRL.showStatistics = function (evt) {
    return CrsStatistics.show(evt);
  };

  CTRL.toggleMainMenu = function () {
    return $mdSidenav('mainmenu').toggle();
  };

  $scope.$watchCollection(function () {
    return CrsStateService.get;
  }, function () {
    CTRL.pageCounterText = CrsStateService.get.pageCounterText;
    CTRL.currentPageNumber = CrsStateService.get.currentPageNumber;
    CTRL.totalPages = CrsStateService.get.totalPages;
    CTRL.courseTitle = CrsStateService.get.courseTitle;
  });
}]);

/**
 * @ngdoc directive
 * @name coreApp:crsAppHeaderDirective
 *
 * @description
 *
 *
 * @restrict A
 * */
angular.module('coreApp').directive('crsAppHeader', function () {
  return {
    restrict: 'E',
    scope: {},
    link: function link(scope, elem, attr) {},
    controller: 'CrsAppHeaderCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'course_player/app/app-header/crsAppHeaderTmpl.html'
  };
});

/**
 * @ngdoc controller
 * @name coreApp:crsAppMainmenuCtrl
 *
 * @description
 *
 *
 * @requires $scope
 * */
angular.module('coreApp').controller('CrsAppMainmenuCtrl', ['$scope', '$mdMedia', '$structure', 'ProgressManager', 'CrsStateService', 'CrsGlossary', 'CrsStatistics', '$mdSidenav', '$window', '_', function ($scope, $mdMedia, $structure, ProgressManager, CrsStateService, CrsGlossary, CrsStatistics, $mdSidenav, $window, _) {
  var CTRL = this;

  CTRL.exit = function () {
    return $window.top.close();
  };
  CTRL.isOpen = function () {
    return $mdSidenav('mainmenu').isOpen();
  };

  CTRL.showGlossary = function (evt) {
    $mdSidenav('mainmenu').close().then(function () {
      return CrsGlossary.show(evt);
    });
  };

  CTRL.showStatistics = function (evt) {
    $mdSidenav('mainmenu').close().then(function () {
      return CrsStatistics.show(evt);
    });
  };

  CTRL.goToPageById = function (page_id) {
    $mdSidenav('mainmenu').close().then(function () {
      return CrsStateService.goToPageById(page_id);
    });
  };

  $scope.$watchCollection(function () {
    return CrsStateService.get;
  }, function () {
    var PROGRESS = CrsStateService.get.progress;
    if (!PROGRESS) return;
    CTRL.pages = _.chain($structure.course.chapters).map(function (ch, i) {
      return _.map(ch.pages, function (pg, j) {
        var HAS_PASSED = void 0,
            HAS_NA = void 0,
            HAS_NOT_PASSED = void 0;
        if (pg.type == 'ex') {
          HAS_PASSED = _.some(PROGRESS.state[i][j].scores, function (c) {
            return c == 1;
          });
          HAS_NA = _.some(PROGRESS.state[i][j].scores, function (c) {
            return c == -1;
          });
          HAS_NOT_PASSED = _.some(PROGRESS.state[i][j].scores, function (c) {
            return c != -1 && c < 1;
          });
        } else {
          HAS_PASSED = PROGRESS.state[i][j].passed;
          HAS_NA = false;
          HAS_NOT_PASSED = false;
        }

        return {
          id: pg.id,
          title: pg.title,
          hasPassed: HAS_PASSED,
          hasNA: HAS_NA,
          hasNotPassed: HAS_NOT_PASSED
        };
      });
    }).flatten().value();
    CTRL.currentPageNumber = CrsStateService.get.currentPageNumber;
  });
}]);

/**
 * @ngdoc directive
 * @name coreApp:crsAppMainmenuDirective
 *
 * @description
 *
 *
 * @restrict A
 * */
angular.module('coreApp').directive('crsAppMainmenu', function () {
  return {
    restrict: 'E',
    scope: {},
    link: function link(scope, elem, attr) {},
    controller: 'CrsAppMainmenuCtrl',
    controllerAs: 'ctrl',
    templateUrl: 'course_player/app/app-mainmenu/crsAppMainmenuTmpl.html'
  };
});

/**
 * Created by aklimenko on 21.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsScrollTop
 *
 * @description
 *
 *
 * @restrict A
 * */
angular.module('coreApp').directive('crsScrollTop', ['CrsStateService', function (CrsStateService) {
  return {
    restrict: 'A',
    link: function link(scope, elem, attr) {
      scope.$watch(function () {
        return CrsStateService.get.currentPageObject;
      }, function () {
        return elem.scrollTop(0);
      });
    }
  };
}]);

/**
 * Created by aklimenko on 11.12.15.
 */

coreApp.directive('pageCounter', function () {
  return {
    restrict: 'E',
    scope: {
      text: '@',
      current: '@',
      total: '@'
    },
    template: '<div class="page-counter">{{text}}{{current}}/{{total}}</div>'
  };
});
/**
 * Created by aklimenko on 08.08.16.
 *
 */

'use strict';

angular.module('coreApp').service('$progress', [function () {
  this.position = function () {
    return {
      chapter: 0,
      page: 0,
      components: 0
    };
  };
  this.score = function () {};
}]);

/**
 * @ngdoc service
 * @name coreApp:CrsStateService
 *
 * @description
 *
 *
 * */
angular.module('coreApp').service('CrsStateService', ['$structure', 'ProgressManager', function ($structure, ProgressManager) {
  var SERVICE = this;
  var _course_title, _totalPages, _god_mode, _pageCounterText, _chapters, _pages, _currentChapterTitle, _currentPageTitle, _currentPageId, _currentPageObject, _currentPageNumber, _isOnFirstPage, _isOnLastPage, _progress, _componentScores;

  // SERVICE.changeLanguage = function () {
  //   var i = StructureManager.get.localization + 1;
  //   if (i >= StructureManager.get.localizations.length) i = 0;
  //   StructureManager.set.localization = i;
  //   SERVICE.update();
  // };

  SERVICE.get = {
    get progress() {
      return _progress;
    },
    get god_mode() {
      return _god_mode;
    },
    get courseTitle() {
      return _course_title;
    },
    get chapters() {
      return _chapters;
    },
    get pages() {
      return _pages;
    },
    get totalPages() {
      return _totalPages;
    },
    get currentPageObject() {
      return _currentPageObject;
    },
    get currentPageTitle() {
      return _currentPageTitle;
    },
    get currentPageId() {
      return _currentPageId;
    },
    get currentPageNumber() {
      return _currentPageNumber;
    },
    get pageCounterText() {
      return _pageCounterText;
    },
    get currentChapterTitle() {
      return _currentChapterTitle;
    },
    get isOnFirstPage() {
      return _isOnFirstPage;
    },
    get isOnLastPage() {
      return _isOnLastPage;
    },
    get componentScores() {
      return _componentScores;
    }
  };

  SERVICE.getCurrentComponentScore = function (component_index) {
    if (!_progress) return undefined;
    var POS = _progress.position;
    return _progress.scores[POS.chapter][POS.page][component_index];
  };

  SERVICE.getPageComponentScores = function (chapterId, pageId, componentId) {
    if (!_progress) return undefined;
    return _progress.scores[chapterId][pageId][componentId];
  };

  SERVICE.goToNextPage = function () {
    return ProgressManager.goToNextPage().then(function () {
      return SERVICE.update();
    });
  };

  SERVICE.goToPreviousPage = function () {
    return ProgressManager.goToPreviousPage().then(function () {
      return SERVICE.update();
    });
  };

  SERVICE.goToPageById = function (page_id) {
    return ProgressManager.goToPageById(page_id).then(function () {
      return SERVICE.update();
    });
  };

  SERVICE.setComponent = function (component_index) {
    return ProgressManager.setComponent(component_index).then(function () {
      return SERVICE.update();
    });
  };

  SERVICE.update = function () {
    ProgressManager.saveProgress();
    _god_mode = $structure.config.god_mode;
    _course_title = $structure.course.title;
    _pageCounterText = $structure.course.templatesConfig.pageCounter.text;
    _chapters = $structure.course.chapters;
    _pages = _.chain($structure.course.chapters).map(function (ch) {
      return ch.pages;
    }).flatten().value();
    _totalPages = _pages.length;

    ProgressManager.get.progress.then(function (response) {
      var CUR_POSITION = response.position;
      var CUR_CHAPTER = $structure.course.chapters[CUR_POSITION.chapter];
      var CUR_PAGE = CUR_CHAPTER.pages[CUR_POSITION.page];
      _currentChapterTitle = CUR_CHAPTER.title;
      _currentPageTitle = CUR_PAGE.title;
      _currentPageObject = CUR_PAGE;
      _currentPageNumber = _.chain($structure.course.chapters).filter(function (c, i) {
        return i < CUR_CHAPTER;
      }).map(function (c) {
        return c.pages;
      }).flatten().value().length + CUR_POSITION.page + 1;
      _isOnFirstPage = CUR_POSITION.chapter == 0 && CUR_POSITION.page == 0;
      _isOnLastPage = CUR_POSITION.chapter == $structure.course.chapters.length - 1 && CUR_POSITION.page == $structure.course.chapters[CUR_POSITION.chapter].pages.length - 1;

      _componentScores = response.scores;
      _progress = response;
      // console.log('State _progress:',_progress)
    });
  };

  SERVICE.update();
}]);

/**
 * Created by ralic on 07.05.2016.
 * @ngdoc factory
 * @name coreApp:ProgressManager
 *
 * @description
 * - Прогресс прохождения **ProgressService**
 * - сохранить результат по компоненту
 * - получить средний результат по слайду
 * - получить средний результат по главе
 * - получить средний результат по курсу
 * - получить номер компонента
 * - получить номер слайда в главе
 * - получить номер слайда в курсе
 * - получить номер главы
 * - сохранить прогресс
 * > отправка данных в LMS
 * > отправка данных в LRS
 *
 * _progress object has JSON data about progress
 * but is has no data about concrete content
 * for concrete content use $structure.course
 *
 * Default progress looks like this below:

 // suspend_data = {
 //   score_raw:'0..100',
 //   position:{
 //     chapter:'0', page:'0', component:'0'
 //   },
 //   session_time:'00:00:00',
 //   lesson_status:'complete/incomplete'
 //   state:{
 //       [ //chapters
 //           [ //pages
 //            {
 //              passed:true,
 //              scores:[-1, 1, 0] //components
 //            }
 //          ]
 //      ]
 //   }
 // }
 * @requires $structure, ScormManager, TinCanManager, $localStorage
 *
 * */
angular.module('coreApp').service('ProgressManager', ['$q', '$structure', 'ScormManager', 'TinCanManager', '$localStorage', '_', function ($q, $structure, ScormManager, TinCanManager, $localStorage, _) {

  var PM = this;
  var _progress = void 0;

  var getChapters = function getChapters() {
    return $structure.course.chapters;
  };

  //Private functions--------------------------------------------------
  /**
   * Validates progress
   * if failed - sets defaults
   * @param progress
   * @returns {boolean}
   * @private
   */
  function _validate(progress) {
    console.log('validate: ', progress);
    var VALID = !!(progress && progress.courseTitle == $structure.course.title && progress.score_raw >= 0 && progress.session_time && (progress.lesson_status == 'complete' || progress.lesson_status == 'incomplete' || progress.lesson_status == 'not attempted') && progress.scores && progress.scores.length == getChapters().length && progress.position && progress.position.chapter >= 0 && progress.position.chapter < getChapters().length && progress.position.page >= 0 && progress.position.page < getChapters()[progress.position.chapter].pages.length && progress.position.component >= 0 && progress.position.component < getChapters()[progress.position.chapter].pages[progress.position.page].components.length);

    console.log('VALID:', VALID);
    return VALID;
  }

  /**
   * Initialize course progress
   * @returns {deferred.promise|{then, always}}
   */
  function _setInitialState() {
    var deferred = $q.defer();
    ScormManager.init();
    if (_validate(ScormManager.getProgress())) {
      _progress = ScormManager.getProgress();
      console.log('_progress from ScormManager:', _progress);

      $localStorage.progress = _progress;
      deferred.resolve(_progress);
    } else if (_validate($localStorage.progress)) {

      _progress = $localStorage.progress;
      console.log('_progress from $localStorage:', _progress);

      deferred.resolve(_progress);
    } else {

      TinCanManager.getState('progress').then(function (response) {
        if (_validate(response)) {
          _progress = response;
          console.log('_progress from TinCanManager:', _progress);
          $localStorage.progress = _progress;
          deferred.resolve(_progress);
        } else {
          deferred.reject('wrong data from TinCan');
        }
      }, function (error) {
        deferred.reject('failed to initialize from TinCan');
      });
    }

    return deferred.promise;
  }

  /**
   * sets progress to default
   * Устанавливает прогресс по умолчанию
   * @returns {{}}
   */
  function _setDefaultProgress() {
    console.log('ProgressService: setDefaultProgress');
    return {
      courseTitle: $structure.course.title,
      score_raw: 0,
      position: {
        chapter: 0,
        page: 0,
        component: 0
      },
      scores: _.map(getChapters(), function (ch) {
        return _.map(ch.pages, function (pg) {
          return _.map(pg.components, function (c) {
            return -1;
          });
        });
      }),
      session_time: '00:00:00',
      lesson_status: 'incomplete',
      state: _.map(getChapters(), function (ch, i) {
        return _.map(ch.pages, function (pg, j) {
          return {
            passed: i == 0 && j == 0,
            scores: _.map(pg.components, function (c) {
              return -1;
            })
          };
        });
      })
    };
  }

  // suspend_data = {
  //   score_raw:'0..100',
  //   position:{
  //     chapter:'0', page:'0', component:'0'
  //   },
  //   session_time:'00:00:00',
  //   lesson_status:'complete/incomplete'
  //   state:{
  //       [ //chapters
  //           [ //pages
  //            {
  //              passed:true,
  //              scores:[-1, 1, 0] //components
  //            }
  //          ]
  //      ]
  //   }
  // }


  /**
   * Returns average weighted score by components
   * Возвращает средневзвешенный результат по компонентам курса
   * @returns {deferred.promise|{then, always}}
   */
  var getAverageWeightedCourseScore = function getAverageWeightedCourseScore(progress) {
    var COMPONENT_WEIGHTS = _.chain(getChapters()).map(function (ch) {
      return ch.pages;
    }).flatten().map(function (pg) {
      return _.map(pg.components, function (c) {
        return pg.type == 'ex' ? c.weight || 1 : 0;
      });
    }).flatten().value();

    var SUM_WEIGHT = _.reduce(COMPONENT_WEIGHTS, function (sum, val) {
      return sum + val;
    }, 0);

    var SUM_PROGRESS = _.chain(progress.state).flattenDeep().map(function (item) {
      return item.scores;
    }).flatten().reduce(function (sum, val, i) {
      if (val < 0) val = 0;
      return sum + parseFloat(val) * COMPONENT_WEIGHTS[i];
    }, 0).value();
    return SUM_PROGRESS / SUM_WEIGHT;
  };

  //Public methods#############################################

  //Getters-------------------------------
  PM.get = {
    /**
     * Возвращает прогресс по курсу
     * @returns {deferred.promise|{then, always}}
     */
    get progress() {
      var DEFERRED = $q.defer();

      if (!_progress) {
        _setInitialState().then(function (response) {
          console.log('_setInitialState -> response:', response);
          DEFERRED.resolve(_progress);
        }, function (error) {
          _progress = _setDefaultProgress();

          console.log('_progress from default:', _progress);
          $localStorage.progress = _progress;
          DEFERRED.resolve(_progress);
        });
      } else {
        DEFERRED.resolve(_progress);
      }

      return DEFERRED.promise;
    },
    /**
     * Возвращает текущее положение в курсе
     * @returns {deferred.promise|{then, always}}
     */
    get currentPosition() {
      return PM.get.progress.then(function (progress) {
        return progress.position;
      });
    },

    get currentPageGlobalNum() {
      return PM.get.progress.then(function (progress) {
        return _.reduce(getChapters(), function (sum, val, i) {
          if (i < progress.position.chapter) return sum + val.pages;else if (i == progress.position.chapter) return sum + progress.position.page;else return sum;
        }, 0);
      });
    }
  };

  //Public functions----------------------
  /**
   * Переходит на следующую страницу в структуре
   * @returns {deferred.promise|{then, always}}
   */
  PM.goToNextPage = function () {
    return PM.get.progress.then(function (progress) {
      var CHAPTERS = getChapters();
      var POS = progress.position;

      if (POS.page == CHAPTERS[POS.chapter].pages.length - 1) {
        if (POS.chapter < CHAPTERS.length - 1) {
          POS.chapter++;
          POS.page = 0;
          POS.component = 0;
        }
      } else {
        POS.page++;
        POS.component = 0;
      }

      progress.state[POS.chapter][POS.page].passed = true;
    });
  };

  /**
   * Переходит на предыдущую страницу в структуре
   * @returns {deferred.promise|{then, always}}
   */
  PM.goToPreviousPage = function () {
    return PM.get.progress.then(function (progress) {
      var POS = progress.position;
      if (POS.page == 0) {
        if (POS.chapter > 0) {
          var CHAPTER = getChapters()[--POS.chapter];
          POS.page = CHAPTER.pages.length - 1;
          POS.component = 0;
        }
      } else {
        POS.page--;
        POS.component = 0;
      }

      progress.state[POS.chapter][POS.page].passed = true;
    });
  };

  /**
   * Переходит на страницу по идентификатору
   * @param page_id
   * @returns {deferred.promise|{then, always}}
   */
  PM.goToPageById = function (page_id) {
    return PM.get.progress.then(function (progress) {
      var POS_CHAPTER = _.find(getChapters(), function (ch) {
        return _.some(ch.pages, function (pg) {
          return pg.id == page_id;
        });
      });
      var POS_PAGE = _.find(POS_CHAPTER.pages, function (pg) {
        return pg.id == page_id;
      });

      var CH_INDEX = _.indexOf(getChapters(), POS_CHAPTER);
      var PG_INDEX = _.indexOf(POS_CHAPTER.pages, POS_PAGE);

      if (CH_INDEX != -1) {
        var POS = progress.position;
        POS.chapter = CH_INDEX;
        POS.page = PG_INDEX;
        POS.component = 0;
        progress.state[POS.chapter][POS.page].passed = true;
      } else {
        console.error('No page with id: ', page_id);
      }
    });
  };

  /**
   * Переходит на компонент страницы по индексу
   * @param component_index
   * @returns {deferred.promise|{then, always}}
   */
  PM.setComponent = function (component_index) {
    return PM.get.progress.then(function (progress) {
      return progress.position.component = component_index;
    });
  };

  /**
   * Сохраняет балл по текущему компоненту
   * @param score
   * @returns {deferred.promise|{then, always}}
   */
  PM.saveComponentScore = function (score) {
    return PM.get.progress.then(function (progress) {
      var POS = progress.position;
      // console.log('saveComponentScore: pos=',POS)
      progress.scores[POS.chapter][POS.page][POS.component] = score;
      progress.state[POS.chapter][POS.page].scores[POS.component] = score;
    });
  };

  /**
   * Сохраняет прогресс в доступных расположениях:
   * - localStorage
   * - LMS
   * - LRS
   * @returns {deferred.promise|{then, always}}
   */
  PM.saveProgress = function () {
    return PM.get.progress.then(function (progress) {
      var averageScore = getAverageWeightedCourseScore(progress);
      if (averageScore * 100 >= progress.score_raw) {
        progress.score_raw = averageScore * 100;
      }

      if ($structure.config.success_score == progress.score_raw) {
        progress.lesson_status = 'completed';
      }

      $localStorage.progress = progress;
      console.warn('ProgressManager:saveProgress', progress);
      ScormManager.setProgress(progress);
      //TinCanManager.sendState('progress', progress);
      //TinCanManager.sendStatements().then(
      //  function(response){
      //    console.log('sendStatements resolved:',response);
      //  },
      //  function(err){
      //    console.log('sendStatements rejected:',err);
      //  }
      //);
    });
  };
}]);

/**
 * Created by aklimenko on 09.12.15.
 * Сервис отвечает за поиск SCORM API,
 *  получение/передачу данных в формате SCORM,
 *  отправку данных в формате курса в курс.
 */

angular.module('coreApp').service('ScormManager', ['scormWrapper', '$structure', '_', '$window', function (scormWrapper, $structure, _, $window) {
  var SCORM_MANAGER = this;
  var startDate = void 0;

  /**
   * Инициализация: поиск API, получение данных, установка их в статус
   */
  SCORM_MANAGER.init = function (APIType) {
    // scormWrapper.setAPIVersion('1.2'); //TODO: remove hardset param
    scormWrapper.doLMSInitialize();

    if (!scormWrapper.LMSIsInitialized()) {
      console.warn('LMS connection failed');
      return;
    } else {
      console.warn('LMS connection successed');

      startTimer();

      $window.onbeforeunload = function () {
        console.log('onbeforeunload');
        scormWrapper.doLMSFinish();
      };
    }

    return SCORM_MANAGER.getProgress;
  };

  SCORM_MANAGER.getProgress = function () {
    if (!scormWrapper.LMSIsInitialized()) return;

    var completionStatus = scormWrapper.doLMSGetValue('cmi.completion_status');
    var SUSPEND_DATA = scormWrapper.doLMSGetValue('cmi.suspend_data').replace(/\*\#/g, '[').replace(/\#\*/g, ']');
    // console.warn(SUSPEND_DATA, SUSPEND_DATA != '', SUSPEND_DATA.length)
    // console.warn('STATUS_COURSE ' + completionStatus)
    if (completionStatus === 'not attempted') {
      scormWrapper.doLMSSetValue('cmi.suspend_data', '');
    }
    SUSPEND_DATA = SUSPEND_DATA || SUSPEND_DATA != '' ? JSON.parse(JSON.stringify(SUSPEND_DATA)) : {};
    console.warn(SUSPEND_DATA, SUSPEND_DATA != '', SUSPEND_DATA.length);
    // if (SUSPEND_DATA.length > 0) return JSON.parse(SUSPEND_DATA);
    return '';
  };

  SCORM_MANAGER.setProgress = function (progress) {
    if (!scormWrapper.LMSIsInitialized()) return;

    var SUSPEND_DATA = JSON.stringify(progress).replace(/\[/g, '*#').replace(/\]/g, '#*');
    scormWrapper.doLMSSetValue("cmi.core.score.raw", progress.score_raw);
    scormWrapper.doLMSSetValue("cmi.core.lesson_location", JSON.stringify(progress.position));
    scormWrapper.doLMSSetValue("cmi.core.session_time", computeTime());
    scormWrapper.doLMSSetValue("cmi.core.lesson_status", progress.lesson_status); //complete incomplete
    scormWrapper.doLMSSetValue("cmi.suspend_data", JSON.stringify(progress)); //full progress object
    scormWrapper.doLMSCommit('');
  };

  // suspend_data = {
  //   score_raw:'0..100',
  //   position:{
  //     chapter:'0', page:'0', component:'0'
  //   },
  //   session_time:'00:00:00',
  //   lesson_status:'complete/incomplete'
  //   state:{
  //       [ //chapters
  //           [ //pages
  //            {
  //              passed:true,
  //              scores:[-1, 1, 0] //components
  //            }
  //          ]
  //      ]
  //   }
  // }

  //Time controls======================================================================================================
  function startTimer() {
    startDate = new Date().getTime();
  }

  function computeTime() {
    if (startDate != 0) {
      var currentDate = new Date().getTime();
      var elapsedSeconds = (currentDate - startDate) / 1000;
      var formattedTime = convertTotalSeconds(elapsedSeconds);
    } else {
      formattedTime = "00:00:00.0";
    }
    return formattedTime;
  }

  /*******************************************************************************
   ** this function will convert seconds into hours, minutes, and seconds in
   ** CMITimespan type format - HHHH:MM:SS.SS (Hours has a max of 4 digits &
   ** Min of 2 digits
   *******************************************************************************/
  function convertTotalSeconds(ts) {
    var sec = ts % 60;

    ts -= sec;
    var tmp = ts % 3600; //# of seconds in the total # of minutes
    ts -= tmp; //# of seconds in the total # of hours

    // convert seconds to conform to CMITimespan type (e.g. SS.00)
    sec = Math.round(sec * 100) / 100;

    var strSec = new String(sec);
    var strWholeSec = strSec;
    var strFractionSec = "";

    if (strSec.indexOf(".") != -1) {
      strWholeSec = strSec.substring(0, strSec.indexOf("."));
      strFractionSec = strSec.substring(strSec.indexOf(".") + 1, strSec.length);
    }

    if (strWholeSec.length < 2) {
      strWholeSec = "0" + strWholeSec;
    }
    strSec = strWholeSec;

    if (strFractionSec.length) {
      strSec = strSec + "." + strFractionSec;
    }

    if (ts % 3600 != 0) var hour = 0;else var hour = ts / 3600;
    if (tmp % 60 != 0) var min = 0;else var min = tmp / 60;

    if (new String(hour).length < 2) hour = "0" + hour;
    if (new String(min).length < 2) min = "0" + min;

    var rtnVal = hour + ":" + min + ":" + strSec;

    return rtnVal;
  }

  return SCORM_MANAGER;
}]);

/**
 * Created by aklimenko on 07.12.15.
 *
 * @ngdoc service
 * @name coreApp:StructureManager
 *
 * @description
 *
 * Сервис для работы со структурой.
 * Содержит информацию о главах, страницах, заданиях, и тестах
 *
 * */

angular.module('coreApp').service('StructureManager', ['$structure', function ($structure) {

  var SM = this;

  var _localization = $structure.config.default_localization;

  SM.set = {
    /**
     *
     * @param value
     */
    set god_mode(value) {
      $structure.config.god_mode = value;
    },

    set localization(id) {
      if (!$structure.config.localizations[id]) {
        id = $structure.config.default_localization;
      }
      _localization = id;
      $structure.course = $structure.courses[_localization];
      console.log('Change localization to ', $structure.config.localizations[id]);
    }
  };

  SM.get = {
    /**
     * Returns main course params
     * @returns {{id: *, title: *}}
     */
    get course_params() {
      //console.log('structure: ', $structure);
      return {
        id: $structure.config.id,
        title: $structure.course.title
      };
    },

    /**
     * Returns templates configurations
     * @returns {*}
     */
    get templates() {
      return $structure.course.templatesConfig;
    },
    /**
     *
     * @returns {boolean}
     */
    get god_mode() {
      return $structure.config.god_mode;
    },
    /**
     *
     * @returns {boolean}
     */
    get page_block() {
      return $structure.config.page_block;
    },
    /**
     *
     * @returns {boolean}
     */
    get ex_block() {
      return $structure.config.ex_block;
    },

    get localization() {
      return _localization;
    },

    get localizations() {
      return $structure.config.localizations;
    },

    get modals() {
      return $structure.course.modals;
    },

    /**
     * Возвращает массив всех глав курса
     * @returns {Array}
     */
    get chapters() {
      return $structure.course.chapters;
    },

    /**
     * Возвращает массив всех страниц курса
     * @returns {Array}
     */
    get pages() {
      var pages = [];
      angular.forEach($structure.course.chapters, function (chapter, chapNum) {
        angular.forEach(chapter.pages, function (page, pageNum) {
          pages.push(page);
        });
      });
      return pages;
    },
    /**
     * Возвращает массив всех заданий курса
     * @returns {Array}
     */
    get tasks() {
      var tasks = [];
      angular.forEach(SM.get.pages, function (page, pageNum) {
        angular.forEach(page.components, function (component, compNum) {
          if (component.type == 'task') {
            tasks.push(component);
          }
        });
      });
      return tasks;
    },
    /**
     * Возвращает массив всех компонентов курса
     * @returns {Array}
     */
    get components() {
      var comps = [];
      angular.forEach(SM.get.pages, function (page, pageNum) {
        angular.forEach(page.components, function (component, compNum) {
          comps.push(component);
        });
      });
      return comps;
    }

  };

  /**
   * Возвращает глобальный номер страницы
   * по главе и номеру страницы в ней
   * @param chapNum
   * @param pageNum
   * @returns {Number}
   */
  SM.globalPageNumber = function (chapNum, pageNum) {
    var tmp_count = 0;

    for (var i = 0; i < chapNum; i++) {
      tmp_count += SM.get.chapters[i].pages.length;
    }

    return tmp_count * 1 + pageNum * 1;
  };

  /**
   * Возвращает глобальный номер компонента
   * по главе, номеру страницы и номеру компонента в ней
   * @param chapNum
   * @param pageNum
   * @param compNum
   * @returns {*}
   */
  SM.globalComponentNumber = function (chapNum, pageNum, compNum) {
    var tmp_count = 0;

    for (var i = 0; i < chapNum; i++) {
      for (var j = 0; j < SM.get.chapters[i].pages.length; j++) {
        tmp_count += SM.get.chapters[i].pages[j].components.length;
      }
    }

    for (i = 0; i < pageNum; i++) {
      tmp_count += SM.get.chapters[chapNum].pages[i].components.length;
    }

    return parseInt(tmp_count) + parseInt(compNum);
  };

  /**
   * Возвращает объект компонента по номеру главы, страницы, компонента
   * @param chapNum
   * @param pageNum
   * @param compNum
   * @returns {*}
   */
  SM.getComponent = function (chapNum, pageNum, compNum) {
    return SM.get.chapters[chapNum].pages[pageNum].components[compNum];
  };

  /**
   * Возвращает объект страницы по ее id
   * @param pageId
   * @returns {*}
   */
  SM.getPageById = function (pageId) {
    var pageById = null;

    angular.forEach(SM.get.pages, function (page, pageNum) {
      if (!pageById && page.id == pageId) pageById = page;
    });

    return pageById;
  };

  /**
   * Возвращает положение страницы по ее идентификатору
   * @param pageId
   * @returns {null}
   */
  SM.getPagePositionById = function (pageId) {
    var position = null;

    angular.forEach(SM.get.chapters, function (chapter, chapNum) {
      angular.forEach(chapter.pages, function (page, pageNum) {
        if (!position && pageId == page.id) {
          position = {
            chapter: chapNum,
            page: pageNum,
            component: 0
          };
        }
      });
    });

    return position;
  };

  /**
   * Возвращает статус прохождения главы
   * @param chapNum
   * @returns {Boolean}
   */
  SM.isChapterPassed = function (chapNum) {
    return SM.get.chapters[chapNum].passed;
  };
}]);

/**
 * Created by ralic on 10.04.2016.
 */

"use strict";

coreApp.factory('TestTinCanService', ['$q', '$localStorage', 'TinCanManager', function ($q, $localStorage, TinCanManager) {

  var TestTinCan = {};

  var sampleModule = {
    id: 'chapter0',
    name: {
      "en-US": "chapter0",
      "ru": "Глава 0"
    },
    description: {
      "en-US": "Description for Course Chapter 0",
      "ru": "Описание нулевой главы"
    }
  };

  var samplePage = {
    id: 'page0',
    name: {
      "en-US": "page0",
      "ru": "Страница 0"
    },
    description: {
      "en-US": "Description for Course Chapter Page 0",
      "ru": "Описание нулевой страницы"
    }
  };

  var sampleMedia = {
    id: 'media0',
    name: {
      "en-US": "Video0",
      "ru": "Видео 0"
    },
    description: {
      "en-US": "Description for Course Chapter Page Video 0",
      "ru": "Описание видео в нулевой странице"
    }
  };

  var sampleInteraction = {
    id: 'interaction0',
    name: {
      "en-US": "Interaction0",
      "ru": "Интерактив 0"
    },
    description: {
      "en-US": "Description for Course Chapter Page Interaction 0",
      "ru": "Описание для видео 0 на странице 0 в главе 0 в курсе"
    },
    score: {
      completion: true,
      score: 1
    }
  };

  //$localStorage.statements.push(TinCanStatement.courseAttempted);
  //$localStorage.statements.push(TinCanStatement.courseSuspended);
  //$localStorage.statements.push(TinCanStatement.courseCompleted);
  //$localStorage.statements.push(TinCanStatement.courseExited);
  //$localStorage.statements.push(TinCanStatement.moduleInitialized(sampleModule));
  //$localStorage.statements.push(TinCanStatement.lessonExperienced(sampleModule, samplePage));
  //$localStorage.statements.push(TinCanStatement.mediaExperienced(sampleModule, samplePage, sampleMedia));
  //$localStorage.statements.push(TinCanStatement.interactionAttempted(sampleModule, samplePage, sampleInteraction));
  //$localStorage.statements.push(TinCanStatement.interactionPassed(sampleModule, samplePage, sampleInteraction));
  //$localStorage.statements.push(TinCanStatement.interactionFailed(sampleModule, samplePage, sampleInteraction));
  //$localStorage.statements.push(TinCanStatement.interactionMastered(sampleModule, samplePage, sampleInteraction));


  function getDataFromLRS(param) {
    var promise = TinCanManager.get(param);
    promise.then(function (sr) {
      console.log('data get -> success:', sr);
    }, function (reason) {
      console.log("can't get data ->", reason);
    });
  }

  function removeStatements(st_selector) {
    var promise = TinCanManager.get(st_selector);
    promise.then(function (sr) {
      console.log('data get -> success:', sr);
      voidStatements(sr);
    }, function (reason) {
      console.log("can't get data ->", reason);
    });

    function voidStatements(statements) {
      $.each(statements, function (key, st) {
        var voidStmt = TinCanStatement.voidStatement(st.id);
        $localStorage.statements.push(voidStmt);
      });
      TinCanManager.send();
    }
  }

  function saveBookmark(location) {
    var promise = TinCanManager.sendState(TinCanManager.STATES.bookmark, location);
    promise.then(function (result) {
      console.log('bookmark saved -> ', result);
      getBookmark();
    }, function (reason) {
      console.log("can't get bookmark ->", reason);
    });
  }

  function getBookmark() {
    var promise = TinCanManager.getState(TinCanManager.STATES.bookmark);
    promise.then(function (result) {
      console.log('Got bookmark -> ', result);
    }, function (reason) {
      console.log("can't get bookmark ->", reason);
    });
  }

  return {

    testSendStatements: function testSendStatements() {
      var sendPromise = TinCanManager.send();
      sendPromise.then(function (resolved) {
        console.log('statement send ->', resolved);
      }, function (reason) {
        console.log("can't send ->", reason);
      });
    },

    testGetStatements: function testGetStatements() {

      var st_selector = {
        agent: new TinCan.Agent({
          mbox: $localStorage.userEmail
        })
      };

      getDataFromLRS(st_selector);
    },

    testRemoveStatements: function testRemoveStatements() {

      var st_selector = {
        agent: new TinCan.Agent({
          mbox: $localStorage.userEmail
        })
      };

      removeStatements(st_selector);
    },

    testSaveBookmark: function testSaveBookmark() {
      saveBookmark({ chapter: 1, page: 0 });
    }
  };
}]);
/**
 * Created by aklimenko on 09.04.16.
 *
 * @ngdoc service
 * @name coreApp:TinCanManager
 *
 * @description
 *
 * - sets config from $structure and $tincanConfig values *
 * - creates array of LRS objects
 * - send/retrieves statements to/from lrsList
 * - send/retrieves states to/from lrsList
 *
 * */
"use strict";

angular.module('coreApp').service('TinCanManager', ['$q', '$localStorage', '$tincanConfig', function ($q, $localStorage, $tincanConfig) {

  var TM = this;
  var config = $tincanConfig;
  var _lrsList;

  /**
   * Creates LRS object from config params
   *
   * {
  *   "id": "webtutor",
  *   "endpoint": "",
  *   "username": "user1",
  *   "password": "user1"
  * }
   *
   * @param lrs
   * @returns {*}
   */
  function configLRS(lrs) {
    var _lrs;

    try {
      _lrs = new TinCan.LRS({
        endpoint: lrs.endpoint,
        username: lrs.username,
        password: lrs.password,
        allowFail: false
      });
    } catch (ex) {
      console.log("Failed to setup LRS object: ", ex);
      return null;
    }
    console.log("Successfully setup LRS object", _lrs);

    return _lrs;
  }

  TM.get = {

    _getLrsList: function _getLrsList() {
      if (_lrsList) return _lrsList;
      _lrsList = [];
      angular.forEach(config.lrs, function (lrs, lrsNum) {
        var lrs_ready = configLRS(lrs);
        if (lrs_ready) _lrsList.push(lrs_ready);
      });
      return _lrsList;
    },

    get lrsList() {
      return this._getLrsList();
    },

    /**
     *
     * @returns {TinCan.Agent}
     */
    get defaultActor() {
      return new TinCan.Agent({
        //Basic authentification
        mbox: config.defaultActor.mbox, //user e-mail
        name: config.defaultActor.name //user name

        //#################################
        //Identify user by his account in our system
        //Works great with https://cloud.scorm.com/

        //account: new TinCan.AgentAccount({
        //  homePage:'https://cloud.scorm.com/',
        //  name:$localStorage.userAccount
        //})
        //################################
      });
    },

    /**
     *
     * @returns {TinCan.Activity}
     */
    get courseActivity() {
      return new TinCan.Activity({
        id: "http://adlnet.gov/courses/" + config.defaultActivity.id,
        definition: new TinCan.ActivityDefinition({
          name: config.defaultActivity.title,
          description: config.defaultActivity.description,
          type: "http://adlnet.gov/expapi/activities/course"
        })
      });
    },

    /**
     *
     * @returns {{progress}}
     * @constructor
     */
    get STATE() {
      return {
        get progress() {
          return 'progress';
        }
      };
    },

    /**
     * Returns TinCanVerb in different languages
     * @returns {{attempted, suspended, completed, exited, initialized, experienced, passed, failed, mastered, voided}}
     * @constructor
     */
    get VERB() {

      function getVerb(eng, ru) {
        return new TinCan.Verb({
          id: "http://adlnet.gov/expapi/verbs/" + eng,
          display: {
            "en-US": eng,
            "ru": ru
          }
        });
      }

      return {
        get attempted() {
          return getVerb('attempted', 'приступил к');
        },
        get suspended() {
          return getVerb('suspended', 'приостановил');
        },
        get completed() {
          return getVerb('completed', 'окончил');
        },
        get exited() {
          return getVerb('exited', 'закрыл');
        },
        get initialized() {
          return getVerb('initialized', 'начал');
        },
        get experienced() {
          return getVerb('experienced', 'просмотрел');
        },
        get passed() {
          return getVerb('passed', 'прошел');
        },
        get failed() {
          return getVerb('failed', 'провалил');
        },
        get mastered() {
          return getVerb('mastered', 'отлично справился с');
        },
        get voided() {
          return getVerb('voided', 'удалил');
        }
      };
    }
  };

  /**
   * Sends all statements from $localStorage
   *
   * @returns {deferred.promise|{then, always}}
   */
  TM.sendStatements = function () {
    var deferred = $q.defer();

    if (!TM.get.lrsList.length) {
      deferred.reject('no lrs found');
      return deferred.promise;
    }

    var saved_count = 0;
    var errors = [];
    var response_counter = 0;

    angular.forEach(TM.get.lrsList, function (lrs, lrsNum) {
      lrs.saveStatements($localStorage.statements, {
        callback: function callback(err, xhr) {
          if (err !== null) {
            if (xhr !== null) {
              var err_msg = "Failed to save statement: " + xhr.responseText + " (" + xhr.status + ")";
            }

            console.log("Failed to save statement: ", err);
            errors.push({
              err: err,
              xhr: xhr
            });
          } else {
            saved_count++;
          }
          countResponse();
        }
      });
    });

    function countResponse() {
      response_counter++;
      if (response_counter == TM.get.lrsList.length) {
        if (saved_count > 0) {
          deferred.resolve({
            msg: 'success',
            errList: errors
          });
        } else {
          deferred.reject(errors);
        }
      }
    }

    return deferred.promise;
  };

  /**
   * Сохранить статус курса
   *
   * Sends all states from $localStorage.states
   *
   * @param key
   * @param val
   * @returns {deferred.promise|{then, always}}
   */

  TM.sendState = function (key, val) {
    var deferred = $q.defer();

    if (!TM.get.lrsList.length) {
      deferred.reject('no lrs found');
      return deferred.promise;
    }

    var saved_count = 0;
    var errors = [];
    var response_counter = 0;

    angular.forEach(TM.get.lrsList, function (lrs, lrsNum) {
      lrs.saveState(key, val, {
        agent: TM.get.defaultActor,
        activity: TM.get.courseActivity,
        contentType: "application/json",
        callback: function callback(err, xhr) {
          if (err !== null) {
            if (xhr !== null) {
              var err_msg = "Failed to save state: " + xhr.responseText + " (" + xhr.status + ")";
            }

            console.log("Failed to save state: ", err);
            errors.push({
              err: err,
              xhr: xhr
            });
          } else {
            saved_count++;
          }
          countResponse();
        }
      });
    });

    function countResponse() {
      response_counter++;
      if (response_counter == TM.get.lrsList.length) {
        if (saved_count > 0) {
          deferred.resolve({
            msg: 'success',
            errList: errors
          });
        } else {
          deferred.reject(errors);
        }
      }
    }

    return deferred.promise;
  };

  /**
   * Get state by key
   * - TODO: last by timestamp from lrsList
   *
   * @param key
   * @returns {deferred.promise|{then, always}}
   */
  TM.getState = function (key) {
    var deferred = $q.defer();

    if (!TM.get.lrsList.length) {
      deferred.reject('no lrs found');
      return deferred.promise;
    }

    var result_states = [];
    var errors = [];

    var response_counter = 0;

    angular.forEach(TM.get.lrsList, function (lrs, lrsNum) {
      lrs.retrieveState(key, {
        agent: TM.get.defaultActor,
        activity: TM.get.courseActivity,
        contentType: "application/json",
        callback: function callback(err, result) {
          if (err !== null) {

            console.log("Failed to get state: ", err);
            errors.push(err);
          } else {
            result_states.push(result);
          }

          countResponse();
        }
      });
    });

    function countResponse() {
      response_counter++;
      if (response_counter == TM.get.lrsList.length) {
        if (result_states.length > 0) {
          deferred.resolve({
            msg: 'success',
            results: result_states,
            errList: errors
          });
        } else {
          deferred.reject(errors);
        }
      }
    }

    return deferred.promise;
  };
}]);

/**
 * Created by aklimenko on 09.04.2016.
 *
 * Generates statements to in TinCan format
 */
"use strict";

coreApp.factory('TinCanStatement', ['TinCanManager', '$localStorage', function (TinCanManager, $localStorage) {
  /** https://github.com/adlnet/xAPI-Spec/blob/master/xAPI.md#40-statement **/

  //TODO: set context to course/chapter
  //context: {
  //  contextActivities: {
  //    grouping: [
  //      {
  //        id: "http://adlnet.gov/courses/compsci/CS204/",
  //        definition: {
  //          name: {
  //            "en-US": "CS204"
  //          },
  //          description: {
  //            "en-US": "The activity representing the course CS204"
  //          },
  //          type: "http://adlnet.gov/expapi/activities/course"
  //        }
  //      },
  //      {
  //        id: "http://adlnet.gov/courses/compsci/CS204/lesson01/01?attemptId=50fd6961-ab6c-4e75-e6c7-ca42dce50dd6",
  //        definition: {
  //          name: {
  //            "en-US": "Attempt of CS204 lesson 01"
  //          },
  //          description: {
  //            "en-US": "The activity representing an attempt of lesson 01 in the course CS204"
  //          },
  //          type: "http://adlnet.gov/expapi/activities/attempt"
  //        }
  //      }
  //    ],
  //    category: [
  //      {
  //        id: "https://w3id.org/xapi/adl/profiles/scorm"
  //      }
  //    ]
  //  }
  //}
  //},{
  //  storeOriginal:false, //-true if we need to store statement as JSON and get it later by |statement.originalJSON|
  //  doStamp:true //Whether to automatically set the 'id' and 'timestamp' properties (default: true)
  //});

  return {
    /** http://xapi.vocab.pub/datasets/adl/ **/

    /** http://activitystrea.ms/specs/json/schema/activity-schema.html **/
    //курс запущен
    courseAttempted: new TinCan.Statement({
      actor: TinCanManager.get.defaultActor,
      target: TinCanManager.get.courseActivity,
      verb: TinCanManager.get.VERB.attempted
    }, {
      storeOriginal: false, //-true if we need to store statement as JSON and get it later by |statement.originalJSON|
      doStamp: true //Whether to automatically set the 'id' and 'timestamp' properties (default: true)
    }),

    //курс приостановлен
    courseSuspended: function courseSuspended(score) {
      new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: TinCanManager.get.courseActivity,
        verb: TinCanManager.get.VERB.suspended,
        result: new TinCan.Result({
          score: new TinCan.Score({
            scaled: $localStorage.progress.course.score
          })
        })
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //курс закрыт
    courseExited: function courseExited(score) {
      new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: TinCanManager.get.courseActivity,
        verb: TinCanManager.get.VERB.exited,
        result: new TinCan.Result({
          score: new TinCan.Score({
            scaled: $localStorage.progress.course.score
          })
        })
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //курс успешно завершен
    courseCompleted: function courseCompleted(score) {
      new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: TinCanManager.courseActivity,
        verb: TinCanManager.VERB.completed,
        result: new TinCan.Result({
          score: new TinCan.Score({
            scaled: score
            //min:0,
            //max:100,
            //raw:score_raw
          })
        })
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //глава начата
    chapterInitialized: function chapterInitialized(chapter) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: new TinCan.Activity({
          id: "http://adlnet.gov/courses/" + $localStorage.progress.course.id + "/" + chapter.id,
          definition: new TinCan.ActivityDefinition({
            name: chapter.name,
            description: chapter.description,
            type: "http://adlnet.gov/expapi/activities/chapter"
          })
        }),
        verb: TinCanManager.get.VERB.initialized
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //глава завершена
    chapterPassed: function chapterPassed(chapter) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: new TinCan.Activity({
          id: "http://adlnet.gov/courses/" + $localStorage.progress.course.id + "/" + chapter.id,
          definition: new TinCan.ActivityDefinition({
            name: chapter.name,
            description: chapter.description,
            type: "http://adlnet.gov/expapi/activities/chapter"
          })
        }),
        verb: TinCanManager.get.VERB.passed
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //страница просмотрена
    lessonExperienced: function lessonExperienced(chapter, page) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: new TinCan.Activity({
          id: "http://adlnet.gov/courses/" + $localStorage.progress.course.id + "/" + chapter.id + "/" + page.id,
          definition: new TinCan.ActivityDefinition({
            name: page.name,
            description: page.description,
            type: "http://adlnet.gov/expapi/activities/lesson"
          })
        }),
        verb: TinCanManager.get.VERB.experienced
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //картинка/текст/видео просмотрены
    mediaExperienced: function mediaExperienced(chapter, page, media) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: new TinCan.Activity({
          id: "http://adlnet.gov/courses/" + $localStorage.progress.course.id + "/" + chapter.id + "/" + page.id + "/" + media.id,
          definition: new TinCan.ActivityDefinition({
            name: media.name,
            description: media.description,
            type: "http://adlnet.gov/expapi/activities/media"
          })
        }),
        verb: TinCanManager.get.VERB.experienced
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //интерактив начат
    interactionAttempted: function interactionAttempted(chapter, page, interaction) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: new TinCan.Activity({
          id: "http://adlnet.gov/courses/" + $localStorage.progress.course.id + "/" + chapter.id + "/" + page.id + "/" + interaction.id,
          definition: new TinCan.ActivityDefinition({
            name: interaction.name,
            description: interaction.description,
            type: "http://adlnet.gov/expapi/activities/interaction"
          })
        }),
        verb: TinCanManager.get.VERB.attempted
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //интерактив пройден
    interactionPassed: function interactionPassed(chapter, page, interaction) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: new TinCan.Activity({
          id: "http://adlnet.gov/courses/" + $localStorage.progress.course.id + "/" + chapter.id + "/" + page.id + "/" + interaction.id,
          definition: new TinCan.ActivityDefinition({
            name: interaction.name,
            description: interaction.description,
            type: "http://adlnet.gov/expapi/activities/interaction"
          })
        }),
        verb: TinCanManager.get.VERB.passed,
        result: new TinCan.Result({
          score: new TinCan.Score(interaction.score)
        })
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //интерактив завершен неудачно
    interactionFailed: function interactionFailed(chapter, page, interaction) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: new TinCan.Activity({
          id: "http://adlnet.gov/courses/" + $localStorage.progress.course.id + "/" + chapter.id + "/" + page.id + "/" + interaction.id,
          definition: new TinCan.ActivityDefinition({
            name: interaction.name,
            description: interaction.description,
            type: "http://adlnet.gov/expapi/activities/interaction"
          })
        }),
        verb: TinCanManager.get.VERB.failed,
        result: new TinCan.Result({
          score: new TinCan.Score(interaction.score)
        })
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //интерактив завершен успешно
    interactionMastered: function interactionMastered(chapter, page, interaction) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        target: new TinCan.Activity({
          id: "http://adlnet.gov/courses/" + $localStorage.progress.course.id + "/" + chapter.id + "/" + page.id + "/" + interaction.id,
          definition: new TinCan.ActivityDefinition({
            name: interaction.name,
            description: interaction.description,
            type: "http://adlnet.gov/expapi/activities/interaction"
          })
        }),
        verb: TinCanManager.get.VERB.mastered,
        result: new TinCan.Result({
          score: new TinCan.Score(interaction.score)
        })
      }, {
        storeOriginal: false,
        doStamp: true
      });
    },

    //обнулить statement
    voidStatement: function voidStatement(id) {
      return new TinCan.Statement({
        actor: TinCanManager.get.defaultActor,
        verb: TinCanManager.get.VERB.voided,
        object: new TinCan.StatementRef({
          id: id
        })
      }, {
        storeOriginal: false,
        doStamp: true
      });
    }

  };
}]);

/**
 * Created by ralic on 22.03.2016.
 *
 * Service for small utility functions
 */
/**
 * Created by ralic on 22.03.2016.
 * @ngdoc factory
 * @name coreApp:UtilityService
 *
 * @description
 * Service for small utility functions
 *
 * */
'use strict';
angular.module('coreApp').factory('UtilityService', ['$http', '$q', function ($http, $q) {
  return {
    /**
     * Converts text to array to wrap blocks by <p> tag.
     * @param txt
     * @returns {*}
     */
    textToBlockArray: function textToBlockArray(txt) {
      if ($.isArray(txt)) {
        return txt;
      } else {
        return [txt];
      }
    },

    randomizeArray: function randomizeArray(givenArray) {
      var array = [];

      for (var i = 0; i < givenArray.length; i++) {
        array.push(givenArray[i]);
      }

      var currentIndex = array.length,
          temporaryValue,
          randomIndex;

      // While there remain elements to shuffle...
      while (0 !== currentIndex) {

        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }

      return array;
    },

    wikiService: {
      get: function get(termin) {
        if (!termin) return $q.defer().promise;

        return $http.jsonp('http://ru.wikipedia.org/w/api.php?' + ['titles=' + termin.toLowerCase(), 'rawcontinue=true', 'action=query', 'format=json', 'prop=extracts', 'callback=JSON_CALLBACK'].join('&'));
      }
    }

  };
}]);

angular.module("coreApp").controller('CrsTaskRangeMovingBlocksCtrl', ['$scope', function ($scope) {}]);
angular.module('coreApp').directive('crsTaskRangeMovingBlocks', ['UtilityService', function (UtilityService) {
  return {
    restrict: 'E',
    controller: 'CrsTaskCtrl',
    controllerAs: 'ctrl',
    scope: {
      laces: '@',
      withNums: '@',
      rightAnswer: '@',
      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      correctAnswer: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      contentVisible: '@',
      contentInvisible: '@',
      hideDelayTime: '@'
    },
    transclude: true,
    templateUrl: 'components/tasks/task-range-moving-blocks/crsTaskRangeMovingBlocksTmpl.html',
    link: function link(scope, elem, attr) {
      scope.isSelected = function () {
        if (scope.isFailed) {
          return false;
        } else {
          return true;
        }
      };

      var elem = elem[0];
      //scope.isEnded = true;
      /*
       var variants=[
       "Разгрузка транспорта",
       "Приемка товаров",
       "Размещение на хранение",
       "Отборка товаров из мест хранения",
       "Комплектование и упаковка товаров",
       "Погрузка",
       "Внутрискладское помещение грузов"
       ]*/
      /* Перемешиваем варианты ответа */

      // Create remove function (because IE don't support .remove())
      if (!('remove' in Element.prototype)) {
        Element.prototype.remove = function () {
          if (this.parentNode) {
            this.parentNode.removeChild(this);
          }
        };
      }

      var variantList = elem.querySelectorAll(".variant");
      var variants = [];
      for (var i = 0; i < variantList.length; i++) {
        variants[i] = variantList[i].textContent;
      }
      elem.querySelector(".secret-info").remove();

      var ansList = [];
      var moveObj = [];
      var gutterStep = 10;
      var heightBlock = 0;
      var mainBlock = document.querySelector(".form__list");
      var number = [];

      /* Дублируем правильные варианты ответа */
      for (var i = 0; i < variants.length; i++) {
        ansList[i] = variants[i];
      }
      ;

      ansList = UtilityService.randomizeArray(ansList);

      /* Создаём элементы списка */
      for (var i = 0; i < ansList.length; i++) {
        var formLi = document.createElement('li');
        formLi.className = "form__item";
        elem.querySelector(".form__list").appendChild(formLi);
      }
      ;

      /* Заполняем элементы списка содержимым */

      var items = elem.querySelectorAll(".form__item");
      for (var i = 0; i < ansList.length; i++) {
        items[i].innerHTML = '<span class="fa fa-arrow-up form__arrow form__arrow--up"></span><p class="form__item-text">' + ansList[i] + '</p><span class="fa fa-arrow-down form__arrow form__arrow--down"></span>';
        // heightBlock = heightBlock < items[i].offsetHeight ? items[i].offsetHeight : heightBlock;
        heightBlock = 48;
      }
      ;

      /* Задаём размер блоку, абсолютно позиционируем и располагаем элементы в блоке */
      mainBlock.style.height = (heightBlock + gutterStep) * ansList.length + 'px';
      for (var i = 0; i < ansList.length; i++) {
        moveObj[i] = i * (heightBlock + gutterStep);
        items[i].style.position = 'absolute';
        items[i].style.transition = '0.7s';
        items[i].style.top = moveObj[i] + 'px';
        number[i] = i;
      }
      ;

      var arrowList = elem.querySelectorAll('.form__arrow');
      for (var i = 0; i < arrowList.length; i++) {
        arrowList[i].addEventListener('click', arrowClickHandler);
      }

      function arrowClickHandler(event) {
        var el = event.target;
        el.parentNode.style.zIndex = 5;

        /* Получаем номер элемента списка, внутри которого произошёл клик на стрелку */
        function GetIdx() {
          var text = event.target.parentElement.querySelector(".form__item-text").textContent;
          var idx = ansList.indexOf(text);
          return idx;
        };

        /* блокировка стрелок элементов списка, находящихся в крайних положениях + учёт состояния кнопки "Ответить" */

        if (!scope.isEnded) {
          var k = GetIdx();
          var currentElemIdx = 0;
          var toggleElemIdx = 0;
          var toggleElem;

          if (angular.element(el).hasClass('form__arrow--down')) {
            if (k !== ansList.length - 1) {
              toggleElem = ansList[k + 1];

              ansList[k + 1] = ansList[k];
              ansList[k] = toggleElem;

              currentElemIdx = k;
              toggleElemIdx = k + 1;
            }
            ;
          } else if (angular.element(el).hasClass('form__arrow--up')) {
            if (k !== 0) {
              toggleElem = ansList[k - 1];
              ansList[k - 1] = ansList[k];
              ansList[k] = toggleElem;

              currentElemIdx = k;
              toggleElemIdx = k - 1;
            }
            ;
          }
          ;
          toggle(currentElemIdx, toggleElemIdx);
        }

        function toggle(currIdx, toggIdx) {
          if (currIdx > toggIdx) {
            var removed = ansList.slice(currIdx, 1);
            ansList.slice(toggIdx, 0, removed);
          } else {
            var removed = ansList.slice(toggIdx, 1);
            ansList.slice(currIdx, 0, removed);
          }
          ;
          var d = number[toggIdx];
          number[toggIdx] = number[currIdx];
          number[currIdx] = d;

          items[number[toggIdx]].style.top = moveObj[toggIdx] + 'px';
          items[number[currIdx]].style.top = moveObj[currIdx] + 'px';

          setTimeout(function () {
            items[number[toggIdx]].style.zIndex = 0;
          }, 700);
        };
      }

      scope.accept = function () {
        scope.isEnded = true;

        /* Сравниваем элементы массивов */
        function isCompared(arr1, arr2) {
          return arr1.filter(function (item, index) {
            return item === arr2[index];
          }).length == arr1.length;
        };

        if (isCompared(ansList, variants)) {
          scope.changeResult(1);
        } else {
          scope.changeResult(0);
        }
        ;
      };

      scope.deactivateButton = function () {
        scope.isEnded = true;
        if (scope.rightAnswerShow == 'true') {
          for (var i = 0; i < ansList.length; i++) {
            items[i].style.top = moveObj[i] + 'px';
          };
          for (var i = 0; i < ansList.length; i++) {
            items[i].querySelector('.form__item-text').innerHTML = variants[i];
          };
          console.info('Показываем правильный ответ', scope.rightAnswerShow);
        } else {
          console.info('Не Показываем правильный ответ', scope.rightAnswerShow);
        }
        scope.isSelected();
      };

      scope.restart = function () {
        scope.isEnded = false;
        ansList = UtilityService.randomizeArray(ansList);

        for (var i = 0; i < ansList.length; i++) {
          items[i].querySelector('.form__item-text').innerHTML = ansList[i];
          number[i] = i;
          items[i].style.top = moveObj[i] + 'px';
        }
        ;
      };
    }
  };
}]);
/**
 * Created by aklimenko on 09.12.15.
 * Контроллер отвечает за работу со страницей курса
 */

'use strict';

coreApp.controller('CrsAppContentPageCtrl', ['$scope', 'CrsStateService', function ($scope, CrsStateService) {
  var CTRL = this;

  $scope.$watchCollection(function () {
    return CrsStateService.get;
  }, function () {
    CTRL.isActive = function (index) {
      return CrsStateService.get.currentComponentIndex == index;
    };
  });
}]);

/**
 * Created by ralic on 27.03.2016.
 */

coreApp.directive('crsAppContentPage', [function () {

  return {
    restrict: 'E',
    scope: {
      pageNumber: '@',
      page: '='
    },
    controller: 'CrsAppContentPageCtrl',
    controllerAs: 'ctrl',
    replace: true,
    templateUrl: 'course_player/app/app-content-page/crsAppContentPageTmpl.html'
  };
}]);
angular.module("coreApp").controller('CrsTaskRangeMovingBlocksTableCtrl', ['$scope', function ($scope) {}]);
angular.module('coreApp').directive('crsTaskRangeMovingBlocksTable', ['UtilityService', function (UtilityService) {
  return {
    restrict: 'E',
    controller: 'CrsTaskCtrl',
    controllerAs: 'ctrl',
    scope: {
      laces: '@',
      withNums: '@',
      rightAnswer: '@',
      rightAnswerShow: '@',
      componentIndex: '@',
      layoutGtSm: '@',
      attempts: '@',
      incorrectAnswer0: '@',
      incorrectAnswer1: '@',
      incorrectAnswer2: '@',
      contentVisible: '@',
      contentInvisible: '@',
      hideDelayTime: '@'
    },
    transclude: true,
    templateUrl: 'components/tasks/task-range-moving-blocks-table/crsTaskRangeMovingBlocksTableTmpl.html',
    link: function link(scope, elem, attr) {
      scope.isSelected = function () {
        if (scope.isFailed) {
          return false;
        } else {
          return true;
        }
      };
      var elem = elem[0];
      //scope.isEnded = true;
      /*
       var variants=[
       "Разгрузка транспорта",
       "Приемка товаров",
       "Размещение на хранение",
       "Отборка товаров из мест хранения",
       "Комплектование и упаковка товаров",
       "Погрузка",
       "Внутрискладское помещение грузов"
       ]*/
      /* Перемешиваем варианты ответа */

      var variantList = elem.querySelectorAll(".variant");
      var variants = [];
      for (var i = 0; i < variantList.length; i++) {
        variants[i] = variantList[i].textContent;
      }
      elem.querySelector(".secret-info").remove();

      var ansList = [];
      var moveObj = [];
      var gutterStep = 10;
      var heightBlock = 0;
      var mainBlock = document.querySelector(".form__list");
      var number = [];

      /* Дублируем правильные варианты ответа */
      for (var i = 0; i < variants.length; i++) {
        ansList[i] = variants[i];
      }
      ;

      ansList = UtilityService.randomizeArray(ansList);

      /* Создаём элементы списка */
      for (var i = 0; i < ansList.length; i++) {
        var formLi = document.createElement('li');
        formLi.className = "form__item";
        elem.querySelector(".form__list").appendChild(formLi);
      }
      ;

      /* Заполняем элементы списка содержимым */

      var items = elem.querySelectorAll(".form__item");
      for (var i = 0; i < ansList.length; i++) {
        items[i].innerHTML = '<span class="fa fa-arrow-up form__arrow form__arrow--up"></span><p class="form__item-text">' + ansList[i] + '</p><span class="fa fa-arrow-down form__arrow form__arrow--down"></span>';
        // heightBlock = heightBlock < items[i].offsetHeight ? items[i].offsetHeight : heightBlock;
        heightBlock = 48;
      }
      ;

      /* Задаём размер блоку, абсолютно позиционируем и располагаем элементы в блоке */
      mainBlock.style.height = (heightBlock + gutterStep) * ansList.length + 'px';
      for (var i = 0; i < ansList.length; i++) {
        moveObj[i] = i * (heightBlock + gutterStep);
        items[i].style.position = 'absolute';
        items[i].style.top = moveObj[i] + 'px';
        number[i] = i;
      }
      ;

      var arrowList = elem.querySelectorAll('.form__arrow');
      for (var i = 0; i < arrowList.length; i++) {
        arrowList[i].addEventListener('click', arrowClickHandler);
      }

      function arrowClickHandler(event) {
        var el = event.target;

        /* Получаем номер элемента списка, внутри которого произошёл клик на стрелку */
        function GetIdx() {
          var text = event.target.parentElement.querySelector(".form__item-text").textContent;
          var idx = ansList.indexOf(text);
          return idx;
        };

        /* блокировка стрелок элементов списка, находящихся в крайних положениях + учёт состояния кнопки "Ответить" */

        if (!scope.isEnded) {
          var k = GetIdx();
          var currentElemIdx = 0;
          var toggleElemIdx = 0;
          var toggleElem;

          if (angular.element(el).hasClass('form__arrow--down')) {
            if (k !== ansList.length - 1) {
              toggleElem = ansList[k + 1];

              ansList[k + 1] = ansList[k];
              ansList[k] = toggleElem;

              currentElemIdx = k;
              toggleElemIdx = k + 1;
            }
            ;
          } else if (angular.element(el).hasClass('form__arrow--up')) {
            if (k !== 0) {
              toggleElem = ansList[k - 1];
              ansList[k - 1] = ansList[k];
              ansList[k] = toggleElem;

              currentElemIdx = k;
              toggleElemIdx = k - 1;
            }
            ;
          }
          ;
          toggle(currentElemIdx, toggleElemIdx);
        }

        function toggle(currIdx, toggIdx) {
          if (currIdx > toggIdx) {
            var removed = ansList.slice(currIdx, 1);
            ansList.slice(toggIdx, 0, removed);
          } else {
            var removed = ansList.slice(toggIdx, 1);
            ansList.slice(currIdx, 0, removed);
          }
          ;
          var d = number[toggIdx];
          number[toggIdx] = number[currIdx];
          number[currIdx] = d;

          items[number[toggIdx]].style.top = moveObj[toggIdx] + 'px';
          items[number[toggIdx]].style.transition = '1s';
          items[number[toggIdx]].style.zIndex = 5;
          items[number[currIdx]].style.top = moveObj[currIdx] + 'px';
          items[number[currIdx]].style.transition = '1s';
          items[number[currIdx]].style.zIndex = 4;
        };
      }

      scope.accept = function () {
        scope.isEnded = true;

        /* Сравниваем элементы массивов */
        function isCompared(arr1, arr2) {
          return arr1.filter(function (item, index) {
            return item === arr2[index];
          }).length == arr1.length;
        };

        if (isCompared(ansList, variants)) {
          scope.changeResult(1);
        } else {
          scope.changeResult(0);
        }
        ;
      };

      scope.deactivateButton = function () {
        scope.isEnded = true;
        if (scope.rightAnswerShow == 'true') {
          for (var i = 0; i < ansList.length; i++) {
            items[i].style.top = moveObj[i] + 'px';
          };
          for (var i = 0; i < ansList.length; i++) {
            items[i].querySelector('.form__item-text').innerHTML = variants[i];
          };
          console.info('Показываем правильный ответ', scope.rightAnswerShow);
        } else {
          console.info('Не Показываем правильный ответ', scope.rightAnswerShow);
        }
        scope.isSelected();
      };

      scope.restart = function () {
        scope.isEnded = false;
        ansList = UtilityService.randomizeArray(ansList);

        for (var i = 0; i < ansList.length; i++) {
          items[i].querySelector('.form__item-text').innerHTML = ansList[i];
          number[i] = i;
          items[i].style.top = moveObj[i] + 'px';
        }
        ;
      };
    }
  };
}]);
/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsAccordionItemContent
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsAccordionItemContent', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    //controller: 'CrsAccordionItemContentCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div class="crs-accordion-item-content" ng-transclude></div>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsAccordionItemHeader
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsAccordionItemHeader', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    //controller: 'CrsAccordionItemHeaderCtrl',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<uib-accordion-heading class="crs-accordion-item-header" ng-transclude></uib-accordion-heading>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsCatalogItemContent
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsCatalogItemContent', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    //controller: '',
    controllerAs: 'ctrl',
    transclude: true,
    replace: true,
    template: '<md-card-content class="crs-catalog-item-content" ng-transclude></md-card-content>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsCatalogItemFooter
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsCatalogItemFooter', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    //controller: '',
    controllerAs: 'ctrl',
    transclude: true,
    replace: true,
    template: '<md-card-footer class="crs-catalog-item-footer"><ng-transclude></ng-transclude></md-card-footer>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsCatalogItemHeader
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsCatalogItemHeader', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    //controller: '',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<md-card-title class="crs-catalog-item-header">' + '<md-card-title-text ng-transclude>' + '</md-card-title-text>' + '</md-card-title>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsCatalogItemImage
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsCatalogItemImg', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {
      if (!scope.alt) scope.noImage = "image " + scope.src;
    },
    scope: {
      src: '@',
      alt: '@'
    },
    //controller: '',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<div class="crs-catalog-item-img" ng-transclude></div>'
  };
});

/**
 * Created by aklimenko on 07.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsCatalogItemVideoDirective
 *
 * @description
 *
 *
 * @restrict E
 * */
angular.module('coreApp').directive('crsCatalogItemVideoDirective', function () {
  return {
    restrict: 'E',
    link: function link(scope, elem, attr) {},
    scope: {},
    //controller: '',
    controllerAs: 'ctrl',
    transclude: true,
    template: '<md-card-content class="crs-catalog-item-video"><ng-transclude></ng-transclude></md-card-content>'
  };
});

/**
 * Created by aklimenko on 21.06.2016.
 */

angular.module('coreApp').controller('CrsPageComponentCtrl', ['$scope', 'ProgressManager', 'CrsStateService', '$mdToast', function ($scope, ProgressManager, CrsStateService, $mdToast) {
  $scope.result = CrsStateService.getCurrentComponentScore($scope.componentIndex);
  //console.log('set result from CrsPageComponentCtrl:', $scope.result);
}]);

/**
 * Created by aklimenko on 21.06.2016.
 */
/**
 * @ngdoc directive
 * @name coreApp:crsPageComponent
 *
 * @description
 * Sets focused component as currentComponent
 *
 * @restrict A
 * */
angular.module('coreApp').directive('crsPageComponent', ['CrsStateService', function (CrsStateService) {
  return {
    restrict: 'A',
    controller: 'CrsPageComponentCtrl',
    link: function link(scope, elem, attr) {
      console.log('crsPageComponentDirective: pageType', scope.pageType);

      elem.on('mouseenter touchstart', function (e) {
        CrsStateService.setComponent(scope.componentIndex);
      });
    },
    scope: {
      componentIndex: '@',
      pageType: '@'
    }
  };
}]);

/********************************************************************************
**
** Prometheus Research SCORM API Wrapper
** 
** Supports:
**
** SCORM 1.2, SCORM 2004.[1]
**
** The following is a porting of the code from the
** original APIWrapper.js file to Angular JS with a 
** number of improvements from
** Concurrent Technologies Corporation (CTC) released
** under the MIT style license available
** on the ADL scorm website [2]
** 
** The code has been updated to wrap the original functions in
** in angularjs and extend support for SCORM 2004 [4].
** It draws upon some of concepts offered in the Pipewerks[3]
** 
** The code is served as an AngularJS service [5].
** 
** References/Inspiration:
** 
** [1] ADL
** http://www.adlnet.gov/scorm
** 
** [2] CTC SCORM SCORM 1.2 API wrapper
** http://www.adlnet.gov/resources/scorm-1-2-content-packages?type=software_downloads
** 
** [3] Pipewerks SCORM wrapper
** https://github.com/pipwerks/scorm-api-wrapper
** 
** [4] SCORM.com
** http://scorm.com/scorm-explained/technical-scorm/run-time/
** 
** [5] Angularjs services
** http://docs.angularjs.org/guide/dev_guide.services
**
** Copyright (c) Prometheus Research 2014
** Copyright (c) Philip Hutchison
** Copyright (c) Concurrent Technologies Corporation (CTC)
** ---------------------------------------------------------------------------------
** License:
** 
** 
** Permission is hereby granted, free of charge, to any person obtaining a 
** copy of this software and associated documentation files (the “Software”), 
** to deal in the Software without restriction, including without limitation the 
** rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
** copies of the Software, and to permit persons to whom the Software is furnished to
** do so, subject to the following conditions:
** 
** The above copyright notice and this permission notice shall be included in 
** all copies or substantial portions of the Software.
** 
** THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
** FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
** COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
** IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
** CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
** 
*********************************************************************************/

var scormwrapper = angular.module('scormwrapper', []);

scormwrapper.service('scormWrapper', function () {
  "use strict";

  var version = "Auto";
  var API = false;
  var scormVersions = ["Auto", "1.2", "2004"];

  this.setAPIVersion = function (scormVersion) {

    scormVersion = scormVersion || "Auto";

    var v = scormVersions.indexOf(scormVersion.toString());
    v > -1 ? version = scormVersions[v] : console.log("Not found, default to Auto");
    return version;
  };

  this.getAPIVersion = function () {
    return version;
  };

  this.isAvailable = function () {
    return true;
  };

  this.doLMSInitialize = function () {
    return this.cmiBooleanToJs(this.getAPICall("LMSInitialize", "Initialize")(""));
  };

  this.doLMSFinish = function () {
    return this.cmiBooleanToJs(this.getAPICall("LMSFinish", "Terminate")(""));
  };

  this.doLMSGetValue = function (parameter) {
    return this.getAPICall("LMSGetValue", "GetValue")(parameter);
  };

  this.doLMSSetValue = function (parameter, value) {
    return this.cmiBooleanToJs(this.getAPICall("LMSSetValue", "SetValue")(parameter, value));
  };

  this.doLMSCommit = function () {
    return this.cmiBooleanToJs(this.getAPICall("LMSCommit", "Commit")(""));
  };

  this.doLMSGetLastError = function () {
    return this.getAPICall("LMSGetLastError", "GetLastError")();
  };

  this.doLMSGetErrorString = function (errorCode) {
    return this.getAPICall("LMSGetErrorString", "GetErrorString")(errorCode.toString());
  };

  this.doLMSGetDiagnostic = function (errorCode) {
    return this.getAPICall("LMSGetDiagnostic", "GetDiagnostic")(errorCode.toString());
  };

  this.LMSIsInitialized = function () {
    return API;
  };

  this.ErrorHandler = function () {
    return this.getAPICall("LMSGetLastError", "GetLastError")();
  };

  this.cmiBooleanToJs = function (value) {
    return value === "1" || value === 1 || value === "true" || value === true;
  };

  this.getAPIHandle = function () {

    var win = window;

    if (win.parent && win.parent != win) {
      this.findAPI(win.parent);
    }

    if (!API && win.top.opener) {
      this.findAPI(win.top.opener);
    } else if (!API) {
      console.log("Unable to find API adapter");
    }
  };

  this.findAPI = function (win) {

    var findAttempts = 0,
        findAttemptLimit = 500;

    for (findAttempts; findAttempts < findAttemptLimit; findAttempts++) {

      if (win.API && (version === "1.2" || version === "Auto")) {
        API = win.API;
        version = "1.2";
        break;
      } else if (win.API_1484_11 && (version === "2004" || version === "Auto")) {
        API = win.API_1484_11;
        version = "2004";
        break;
      } else if (win.parent && win.parent != win) {
        findAttempts++;
        win = win.parent;
      }
    }
  };

  this.getAPICall = function (funcname12, funcname2004) {
    if (!API) {
      this.getAPIHandle();
      if (!API) {
        return function () {
          console.log("No API found, can't execute: " + funcname12 + " or " + funcname2004);
        };
      }
    }

    switch (version) {
      case "2004":
        return function () {
          return API[funcname2004].apply(API, arguments);
        };
        break;

      case "1.2":
        return function () {
          //console.log('API apply arguments:',arguments);
          return API[funcname12].apply(API, arguments);
        };
        break;
    }
  };

  //Objective utils=======================================================================

  this.SCOSetObjectiveData = function (id, elem, value) {
    var result = "false";
    var i = this.SCOGetObjectiveIndex(id);
    if (isNaN(i)) {
      i = parseInt(this.doLMSGetValue('com.objectives.count'));
      if (isNaN(i)) i = 0;
      if (this.doLMSSetValue('com.objectives.' + i + '.id', id) == "true") {
        result = this.doLMSSetValue('com.objectives.' + i + '.' + elem, value);
      }
    } else {}
  };

  /**
   * @return {string}
   */
  this.SCOGetObjectiveData = function (id, elem) {
    var i = this.SCOGetObjectiveIndex(id);
    if (!isNaN(i)) {
      return SCOGetValue("cmi.objectives." + i + "." + elem);
    }
    return "";
  };

  /**
   * @return {number}
   */
  this.SCOGetObjectiveIndex = function (id) {
    var i = -1;
    var nCount = parseInt(this.doLMSGetValue("cmi.objectives._count"));
    if (!isNaN(nCount)) {
      for (i = nCount - 1; i >= 0; i--) {
        //walk backward in case LMS does journaling
        if (this.doLMSGetValue("cmi.objectives." + i + ".id") == id) {
          return i;
        }
      }
    }
    return NaN;
  };

  //Interaction utils=======================================================================

  this.SCOSetInteractionData = function (id, elem, value) {
    var result = "false";
    var i = this.SCOGetInteractionIndex(id);
    if (isNaN(i)) {
      i = parseInt(this.doLMSGetValue('com.interactions.count'));
      if (isNaN(i)) i = 0;
      if (this.doLMSSetValue('com.interactions.' + i + '.id', id) == "true") {
        result = this.doLMSSetValue('com.interactions.' + i + '.' + elem, value);
      }
    } else {}
  };

  /**
   * @return {string}
   */
  this.SCOGetInteractionData = function (id, elem) {
    var i = this.SCOGetInteractionIndex(id);
    if (!isNaN(i)) {
      return SCOGetValue("cmi.interactions." + i + "." + elem);
    }
    return "";
  };

  /**
   * @return {number}
   */
  this.SCOGetInteractionIndex = function (id) {
    var i = -1;
    var nCount = parseInt(this.doLMSGetValue("cmi.interactions._count"));
    if (!isNaN(nCount)) {
      for (i = nCount - 1; i >= 0; i--) {
        //walk backward in case LMS does journaling
        if (this.doLMSGetValue("cmi.interactions." + i + ".id") == id) {
          return i;
        }
      }
    }
    return NaN;
  };
});
/*! iFrame Resizer (iframeSizer.min.js ) - v3.5.3 - 2016-02-23
 *  Desc: Force cross domain iframes to size to content.
 *  Requires: iframeResizer.contentWindow.min.js to be loaded into the target frame.
 *  Copyright: (c) 2016 David J. Bradshaw - dave@bradshaw.net
 *  License: MIT
 */

!function (a) {
  "use strict";
  function b(b, c, d) {
    "addEventListener" in a ? b.addEventListener(c, d, !1) : "attachEvent" in a && b.attachEvent("on" + c, d);
  }function c(b, c, d) {
    "removeEventListener" in a ? b.removeEventListener(c, d, !1) : "detachEvent" in a && b.detachEvent("on" + c, d);
  }function d() {
    var b,
        c = ["moz", "webkit", "o", "ms"];for (b = 0; b < c.length && !N; b += 1) {
      N = a[c[b] + "RequestAnimationFrame"];
    }N || h("setup", "RequestAnimationFrame not supported");
  }function e(b) {
    var c = "Host page: " + b;return a.top !== a.self && (c = a.parentIFrame && a.parentIFrame.getId ? a.parentIFrame.getId() + ": " + b : "Nested host page: " + b), c;
  }function f(a) {
    return K + "[" + e(a) + "]";
  }function g(a) {
    return P[a] ? P[a].log : G;
  }function h(a, b) {
    k("log", a, b, g(a));
  }function i(a, b) {
    k("info", a, b, g(a));
  }function j(a, b) {
    k("warn", a, b, !0);
  }function k(b, c, d, e) {
    !0 === e && "object" == _typeof(a.console) && console[b](f(c), d);
  }function l(d) {
    function e() {
      function a() {
        s(V), p(W);
      }g("Height"), g("Width"), t(a, V, "init");
    }function f() {
      var a = U.substr(L).split(":");return { iframe: P[a[0]].iframe, id: a[0], height: a[1], width: a[2], type: a[3] };
    }function g(a) {
      var b = Number(P[W]["max" + a]),
          c = Number(P[W]["min" + a]),
          d = a.toLowerCase(),
          e = Number(V[d]);h(W, "Checking " + d + " is in range " + c + "-" + b), c > e && (e = c, h(W, "Set " + d + " to min value")), e > b && (e = b, h(W, "Set " + d + " to max value")), V[d] = "" + e;
    }function k() {
      function a() {
        function a() {
          var a = 0,
              d = !1;for (h(W, "Checking connection is from allowed list of origins: " + c); a < c.length; a++) {
            if (c[a] === b) {
              d = !0;break;
            }
          }return d;
        }function d() {
          var a = P[W].remoteHost;return h(W, "Checking connection is from: " + a), b === a;
        }return c.constructor === Array ? a() : d();
      }var b = d.origin,
          c = P[W].checkOrigin;if (c && "" + b != "null" && !a()) throw new Error("Unexpected message received from: " + b + " for " + V.iframe.id + ". Message was: " + d.data + ". This error can be disabled by setting the checkOrigin: false option or by providing of array of trusted domains.");return !0;
    }function l() {
      return K === ("" + U).substr(0, L) && U.substr(L).split(":")[0] in P;
    }function w() {
      var a = V.type in { "true": 1, "false": 1, undefined: 1 };return a && h(W, "Ignoring init message from meta parent page"), a;
    }function y(a) {
      return U.substr(U.indexOf(":") + J + a);
    }function z(a) {
      h(W, "MessageCallback passed: {iframe: " + V.iframe.id + ", message: " + a + "}"), N("messageCallback", { iframe: V.iframe, message: JSON.parse(a) }), h(W, "--");
    }function A() {
      var b = document.body.getBoundingClientRect(),
          c = V.iframe.getBoundingClientRect();return JSON.stringify({ iframeHeight: c.height, iframeWidth: c.width, clientHeight: Math.max(document.documentElement.clientHeight, a.innerHeight || 0), clientWidth: Math.max(document.documentElement.clientWidth, a.innerWidth || 0), offsetTop: parseInt(c.top - b.top, 10), offsetLeft: parseInt(c.left - b.left, 10), scrollTop: a.pageYOffset, scrollLeft: a.pageXOffset });
    }function B(a, b) {
      function c() {
        u("Send Page Info", "pageInfo:" + A(), a, b);
      }x(c, 32);
    }function C() {
      function d(b, c) {
        function d() {
          P[g] ? B(P[g].iframe, g) : e();
        }["scroll", "resize"].forEach(function (e) {
          h(g, b + e + " listener for sendPageInfo"), c(a, e, d);
        });
      }function e() {
        d("Remove ", c);
      }function f() {
        d("Add ", b);
      }var g = W;f(), P[g].stopPageInfo = e;
    }function D() {
      P[W] && P[W].stopPageInfo && (P[W].stopPageInfo(), delete P[W].stopPageInfo);
    }function E() {
      var a = !0;return null === V.iframe && (j(W, "IFrame (" + V.id + ") not found"), a = !1), a;
    }function F(a) {
      var b = a.getBoundingClientRect();return o(W), { x: Math.floor(Number(b.left) + Number(M.x)), y: Math.floor(Number(b.top) + Number(M.y)) };
    }function G(b) {
      function c() {
        M = g, H(), h(W, "--");
      }function d() {
        return { x: Number(V.width) + f.x, y: Number(V.height) + f.y };
      }function e() {
        a.parentIFrame ? a.parentIFrame["scrollTo" + (b ? "Offset" : "")](g.x, g.y) : j(W, "Unable to scroll to requested position, window.parentIFrame not found");
      }var f = b ? F(V.iframe) : { x: 0, y: 0 },
          g = d();h(W, "Reposition requested from iFrame (offset x:" + f.x + " y:" + f.y + ")"), a.top !== a.self ? e() : c();
    }function H() {
      !1 !== N("scrollCallback", M) ? p(W) : q();
    }function I(b) {
      function c() {
        var a = F(g);h(W, "Moving to in page link (#" + e + ") at x: " + a.x + " y: " + a.y), M = { x: a.x, y: a.y }, H(), h(W, "--");
      }function d() {
        a.parentIFrame ? a.parentIFrame.moveToAnchor(e) : h(W, "In page link #" + e + " not found and window.parentIFrame not found");
      }var e = b.split("#")[1] || "",
          f = decodeURIComponent(e),
          g = document.getElementById(f) || document.getElementsByName(f)[0];g ? c() : a.top !== a.self ? d() : h(W, "In page link #" + e + " not found");
    }function N(a, b) {
      return m(W, a, b);
    }function O() {
      switch (P[W].firstRun && T(), V.type) {case "close":
          n(V.iframe);break;case "message":
          z(y(6));break;case "scrollTo":
          G(!1);break;case "scrollToOffset":
          G(!0);break;case "pageInfo":
          B(P[W].iframe, W), C();break;case "pageInfoStop":
          D();break;case "inPageLink":
          I(y(9));break;case "reset":
          r(V);break;case "init":
          e(), N("initCallback", V.iframe), N("resizedCallback", V);break;default:
          e(), N("resizedCallback", V);}
    }function Q(a) {
      var b = !0;return P[a] || (b = !1, j(V.type + " No settings for " + a + ". Message was: " + U)), b;
    }function S() {
      for (var a in P) {
        u("iFrame requested init", v(a), document.getElementById(a), a);
      }
    }function T() {
      P[W].firstRun = !1;
    }var U = d.data,
        V = {},
        W = null;"[iFrameResizerChild]Ready" === U ? S() : l() ? (V = f(), W = R = V.id, !w() && Q(W) && (h(W, "Received: " + U), E() && k() && O())) : i(W, "Ignored: " + U);
  }function m(a, b, c) {
    var d = null,
        e = null;if (P[a]) {
      if (d = P[a][b], "function" != typeof d) throw new TypeError(b + " on iFrame[" + a + "] is not a function");e = d(c);
    }return e;
  }function n(a) {
    var b = a.id;h(b, "Removing iFrame: " + b), a.parentNode.removeChild(a), m(b, "closedCallback", b), h(b, "--"), delete P[b];
  }function o(b) {
    null === M && (M = { x: void 0 !== a.pageXOffset ? a.pageXOffset : document.documentElement.scrollLeft, y: void 0 !== a.pageYOffset ? a.pageYOffset : document.documentElement.scrollTop }, h(b, "Get page position: " + M.x + "," + M.y));
  }function p(b) {
    null !== M && (a.scrollTo(M.x, M.y), h(b, "Set page position: " + M.x + "," + M.y), q());
  }function q() {
    M = null;
  }function r(a) {
    function b() {
      s(a), u("reset", "reset", a.iframe, a.id);
    }h(a.id, "Size reset requested by " + ("init" === a.type ? "host page" : "iFrame")), o(a.id), t(b, a, "reset");
  }function s(a) {
    function b(b) {
      a.iframe.style[b] = a[b] + "px", h(a.id, "IFrame (" + e + ") " + b + " set to " + a[b] + "px");
    }function c(b) {
      H || "0" !== a[b] || (H = !0, h(e, "Hidden iFrame detected, creating visibility listener"), y());
    }function d(a) {
      b(a), c(a);
    }var e = a.iframe.id;P[e] && (P[e].sizeHeight && d("height"), P[e].sizeWidth && d("width"));
  }function t(a, b, c) {
    c !== b.type && N ? (h(b.id, "Requesting animation frame"), N(a)) : a();
  }function u(a, b, c, d) {
    function e() {
      var e = P[d].targetOrigin;h(d, "[" + a + "] Sending msg to iframe[" + d + "] (" + b + ") targetOrigin: " + e), c.contentWindow.postMessage(K + b, e);
    }function f() {
      i(d, "[" + a + "] IFrame(" + d + ") not found"), P[d] && delete P[d];
    }function g() {
      c && "contentWindow" in c && null !== c.contentWindow ? e() : f();
    }d = d || c.id, P[d] && g();
  }function v(a) {
    return a + ":" + P[a].bodyMarginV1 + ":" + P[a].sizeWidth + ":" + P[a].log + ":" + P[a].interval + ":" + P[a].enablePublicMethods + ":" + P[a].autoResize + ":" + P[a].bodyMargin + ":" + P[a].heightCalculationMethod + ":" + P[a].bodyBackground + ":" + P[a].bodyPadding + ":" + P[a].tolerance + ":" + P[a].inPageLinks + ":" + P[a].resizeFrom + ":" + P[a].widthCalculationMethod;
  }function w(a, c) {
    function d() {
      function b(b) {
        1 / 0 !== P[w][b] && 0 !== P[w][b] && (a.style[b] = P[w][b] + "px", h(w, "Set " + b + " = " + P[w][b] + "px"));
      }function c(a) {
        if (P[w]["min" + a] > P[w]["max" + a]) throw new Error("Value for min" + a + " can not be greater than max" + a);
      }c("Height"), c("Width"), b("maxHeight"), b("minHeight"), b("maxWidth"), b("minWidth");
    }function e() {
      var a = c && c.id || S.id + F++;return null !== document.getElementById(a) && (a += F++), a;
    }function f(b) {
      return R = b, "" === b && (a.id = b = e(), G = (c || {}).log, R = b, h(b, "Added missing iframe ID: " + b + " (" + a.src + ")")), b;
    }function g() {
      h(w, "IFrame scrolling " + (P[w].scrolling ? "enabled" : "disabled") + " for " + w), a.style.overflow = !1 === P[w].scrolling ? "hidden" : "auto", a.scrolling = !1 === P[w].scrolling ? "no" : "yes";
    }function i() {
      ("number" == typeof P[w].bodyMargin || "0" === P[w].bodyMargin) && (P[w].bodyMarginV1 = P[w].bodyMargin, P[w].bodyMargin = "" + P[w].bodyMargin + "px");
    }function k() {
      var b = P[w].firstRun,
          c = P[w].heightCalculationMethod in O;!b && c && r({ iframe: a, height: 0, width: 0, type: "init" });
    }function l() {
      Function.prototype.bind && (P[w].iframe.iFrameResizer = { close: n.bind(null, P[w].iframe), resize: u.bind(null, "Window resize", "resize", P[w].iframe), moveToAnchor: function moveToAnchor(a) {
          u("Move to anchor", "inPageLink:" + a, P[w].iframe, w);
        }, sendMessage: function sendMessage(a) {
          a = JSON.stringify(a), u("Send Message", "message:" + a, P[w].iframe, w);
        } });
    }function m(c) {
      function d() {
        u("iFrame.onload", c, a), k();
      }b(a, "load", d), u("init", c, a);
    }function o(a) {
      if ("object" != (typeof a === 'undefined' ? 'undefined' : _typeof(a))) throw new TypeError("Options is not an object");
    }function p(a) {
      for (var b in S) {
        S.hasOwnProperty(b) && (P[w][b] = a.hasOwnProperty(b) ? a[b] : S[b]);
      }
    }function q(a) {
      return "" === a || "file://" === a ? "*" : a;
    }function s(b) {
      b = b || {}, P[w] = { firstRun: !0, iframe: a, remoteHost: a.src.split("/").slice(0, 3).join("/") }, o(b), p(b), P[w].targetOrigin = !0 === P[w].checkOrigin ? q(P[w].remoteHost) : "*";
    }function t() {
      return w in P && "iFrameResizer" in a;
    }var w = f(a.id);t() ? j(w, "Ignored iFrame, already setup.") : (s(c), g(), d(), i(), m(v(w)), l());
  }function x(a, b) {
    null === Q && (Q = setTimeout(function () {
      Q = null, a();
    }, b));
  }function y() {
    function b() {
      function a(a) {
        function b(b) {
          return "0px" === P[a].iframe.style[b];
        }function c(a) {
          return null !== a.offsetParent;
        }c(P[a].iframe) && (b("height") || b("width")) && u("Visibility change", "resize", P[a].iframe, a);
      }for (var b in P) {
        a(b);
      }
    }function c(a) {
      h("window", "Mutation observed: " + a[0].target + " " + a[0].type), x(b, 16);
    }function d() {
      var a = document.querySelector("body"),
          b = { attributes: !0, attributeOldValue: !1, characterData: !0, characterDataOldValue: !1, childList: !0, subtree: !0 },
          d = new e(c);d.observe(a, b);
    }var e = a.MutationObserver || a.WebKitMutationObserver;e && d();
  }function z(a) {
    function b() {
      B("Window " + a, "resize");
    }h("window", "Trigger event: " + a), x(b, 16);
  }function A() {
    function a() {
      B("Tab Visable", "resize");
    }"hidden" !== document.visibilityState && (h("document", "Trigger event: Visiblity change"), x(a, 16));
  }function B(a, b) {
    function c(a) {
      return "parent" === P[a].resizeFrom && P[a].autoResize && !P[a].firstRun;
    }for (var d in P) {
      c(d) && u(a, b, document.getElementById(d), d);
    }
  }function C() {
    b(a, "message", l), b(a, "resize", function () {
      z("resize");
    }), b(document, "visibilitychange", A), b(document, "-webkit-visibilitychange", A), b(a, "focusin", function () {
      z("focus");
    }), b(a, "focus", function () {
      z("focus");
    });
  }function D() {
    function a(a, c) {
      function d() {
        if (!c.tagName) throw new TypeError("Object is not a valid DOM element");if ("IFRAME" !== c.tagName.toUpperCase()) throw new TypeError("Expected <IFRAME> tag, found <" + c.tagName + ">");
      }c && (d(), w(c, a), b.push(c));
    }var b;return d(), C(), function (c, d) {
      switch (b = [], typeof d === 'undefined' ? 'undefined' : _typeof(d)) {case "undefined":case "string":
          Array.prototype.forEach.call(document.querySelectorAll(d || "iframe"), a.bind(void 0, c));break;case "object":
          a(c, d);break;default:
          throw new TypeError("Unexpected data type (" + (typeof d === 'undefined' ? 'undefined' : _typeof(d)) + ")");}return b;
    };
  }function E(a) {
    a.fn.iFrameResize = function (a) {
      return this.filter("iframe").each(function (b, c) {
        w(c, a);
      }).end();
    };
  }var F = 0,
      G = !1,
      H = !1,
      I = "message",
      J = I.length,
      K = "[iFrameSizer]",
      L = K.length,
      M = null,
      N = a.requestAnimationFrame,
      O = { max: 1, scroll: 1, bodyScroll: 1, documentElementScroll: 1 },
      P = {},
      Q = null,
      R = "Host Page",
      S = { autoResize: !0, bodyBackground: null, bodyMargin: null, bodyMarginV1: 8, bodyPadding: null, checkOrigin: !0, inPageLinks: !1, enablePublicMethods: !0, heightCalculationMethod: "bodyOffset", id: "iFrameResizer", interval: 32, log: !1, maxHeight: 1 / 0, maxWidth: 1 / 0, minHeight: 0, minWidth: 0, resizeFrom: "parent", scrolling: !1, sizeHeight: !0, sizeWidth: !1, tolerance: 0, widthCalculationMethod: "scroll", closedCallback: function closedCallback() {}, initCallback: function initCallback() {}, messageCallback: function messageCallback() {
      j("MessageCallback function not defined");
    }, resizedCallback: function resizedCallback() {}, scrollCallback: function scrollCallback() {
      return !0;
    } };a.jQuery && E(jQuery), "function" == typeof define && define.amd ? define([], D) : "object" == (typeof module === 'undefined' ? 'undefined' : _typeof(module)) && "object" == _typeof(module.exports) ? module.exports = D() : a.iFrameResize = a.iFrameResize || D();
}(window || {});
//# sourceMappingURL=iframeResizer.map
/**
 * Created by aklimenko on 18.12.15.
 */

(function ($) {

  $.fn.shuffle = function () {

    var allElems = this.get(),
        getRandom = function getRandom(max) {
      return Math.floor(Math.random() * max);
    },
        shuffled = $.map(allElems, function () {
      var random = getRandom(allElems.length),
          randEl = $(allElems[random]).clone(true)[0];
      allElems.splice(random, 1);
      return randEl;
    });

    this.each(function (i) {
      $(this).replaceWith($(shuffled[i]));
    });

    return $(shuffled);
  };
})(jQuery);